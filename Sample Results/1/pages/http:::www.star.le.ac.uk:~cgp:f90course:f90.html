<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
           "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<meta name="GENERATOR" content="TtH 3.02">
 <style type="text/css"><!--
 td div.comp { margin-top: -0.6ex; margin-bottom: -1ex;}
 td div.comb { margin-top: -0.6ex; margin-bottom: -.6ex;}
 td div.hrcomp { line-height: 0.9; margin-top: -0.8ex; margin-bottom: -1ex;}
 td div.norm {line-height:normal;}
 span.roman {font-family: serif; font-style: normal; font-weight: normal;} 
 span.overacc2 {position: relative;  left: .8em; top: -1.2ex;}
 span.overacc1 {position: relative;  left: .6em; top: -1.2ex;} --></style>

  <BODY BGCOLOR="ANTIQUEWHITE"> 

<title> Fortran90 for Fortran77 Programmers</title>
    
<h1 align="center">Fortran90 for Fortran77 Programmers </h1>

<h3 align="center">Clive Page </h3>

<h3 align="center">2001 November 26 </h3>
 This document may be found at: 
<b>http://www.star.le.ac.uk/~cgp/f90course/f90.html</b>

<p>

<h1>Contents </h1><a href="#tth_sEc1"
>1&nbsp; Introduction</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.1"
>1.1&nbsp; What was wrong with Fortran77?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.2"
>1.2&nbsp; What's New in Fortran90</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.3"
>1.3&nbsp; Benefits</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.4"
>1.4&nbsp; Will old code still work?</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.5"
>1.5&nbsp; Fortran90 Compilers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc1.6"
>1.6&nbsp; The Future</a><br />
<a href="#tth_sEc2"
>2&nbsp; New Look and Feel</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.1"
>2.1&nbsp; Basic Rules for both free and fixed-format</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.2"
>2.2&nbsp; Free-format layout</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc2.3"
>2.3&nbsp; New Forms for Specification Statements</a><br />
<a href="#tth_sEc3"
>3&nbsp; New Control Structures</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.1"
>3.1&nbsp; The <tt>SELECT CASE</tt> Structure</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.2"
>3.2&nbsp; <tt>DO</tt>, <tt>EXIT</tt> and <tt>CYCLE</tt> statements</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.3"
>3.3&nbsp; <tt>DO WHILE</tt> statement</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.4"
>3.4&nbsp; Structure Names</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.5"
>3.5&nbsp; Label-free programming</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc3.6"
>3.6&nbsp; Internal Procedures</a><br />
<a href="#tth_sEc4"
>4&nbsp; Arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.1"
>4.1&nbsp; Declaring and Initialising Arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.2"
>4.2&nbsp; Array-valued expressions and assignments</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.3"
>4.3&nbsp; Array Constructors</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.4"
>4.4&nbsp; Array Sections</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.5"
>4.5&nbsp; Array Intrinsic Functions</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc4.6"
>4.6&nbsp; <tt>WHERE</tt> structure</a><br />
<a href="#tth_sEc5"
>5&nbsp; Dynamic Storage</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.1"
>5.1&nbsp; Automatic Arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.2"
>5.2&nbsp; Allocatable Arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc5.3"
>5.3&nbsp; Pointer arrays</a><br />
<a href="#tth_sEc6"
>6&nbsp; Modules and Interfaces</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.1"
>6.1&nbsp; Example defining constants</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.2"
>6.2&nbsp; Module Procedures</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.3"
>6.3&nbsp; Public and Private accessibility</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.4"
>6.4&nbsp; Avoiding name clashes</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.5"
>6.5&nbsp; Pros and Cons of Modules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc6.6"
>6.6&nbsp; Explicit Interfaces</a><br />
<a href="#tth_sEc7"
>7&nbsp; Procedures and Arguments</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.1"
>7.1&nbsp; Assumed shape arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.2"
>7.2&nbsp; Keyword calls and optional arguments</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.3"
>7.3&nbsp; Generic names</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc7.4"
>7.4&nbsp; Recursive procedures</a><br />
<a href="#tth_sEc8"
>8&nbsp; Derived Data Types (structures)</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.1"
>8.1&nbsp; Accessing Components</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.2"
>8.2&nbsp; Structure constructors</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.3"
>8.3&nbsp; Nested Structures</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.4"
>8.4&nbsp; Pointers as Components</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc8.5"
>8.5&nbsp; Defined and overloaded operators</a><br />
<a href="#tth_sEc9"
>9&nbsp; Input Output</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.1"
>9.1&nbsp; New <tt>OPEN</tt> and <tt>INQUIRE</tt> options</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.2"
>9.2&nbsp; Internal File I/O</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.3"
>9.3&nbsp; Formatted I/O</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc9.4"
>9.4&nbsp; Non-advancing I/O</a><br />
<a href="#tth_sEc10"
>10&nbsp; Character Handling</a><br />
<a href="#tth_sEc11"
>11&nbsp; Pointers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.1"
>11.1&nbsp; Pointer Rules</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.2"
>11.2&nbsp; Array of arrays</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.3"
>11.3&nbsp; Pointer as alias</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.4"
>11.4&nbsp; Function may return a pointer</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc11.5"
>11.5&nbsp; Dynamic Data Structures</a><br />
<a href="#tth_sEc12"
>12&nbsp; Portable Precision</a><br />
<a href="#tth_sEc13"
>13&nbsp; Other features</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.1"
>13.1&nbsp; Bit-wise operations on integers</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc13.2"
>13.2&nbsp; Other intrinsic functions</a><br />
<a href="#tth_sEc14"
>14&nbsp; Resources</a><br />
<a href="#tth_sEc15"
>15&nbsp; Language Progression</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc15.1"
>15.1&nbsp; Deprecated features</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc15.2"
>15.2&nbsp; Superseded features</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc15.3"
>15.3&nbsp; Main New Features of Fortran95</a><br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#tth_sEc15.4"
>15.4&nbsp; Possible New Features of Fortran2000</a><br />
 

<p>
 <h2><a name="tth_sEc1">
1</a>&nbsp;&nbsp;Introduction</h2>

<p>
     <h3><a name="tth_sEc1.1">
1.1</a>&nbsp;&nbsp;What was wrong with Fortran77?</h3>

<p>

<ul><p>
<li> There are no dynamic storage facilities at all.</li>
<p>
<li> There are no user-defined data types or data structures (except the COMMON
block).</li>
<p>
<li> It was too easy to make mistakes which the compiler could not
detect, especially when calling procedures (subroutines or functions). A
study of some 4 million lines of professional Fortran showed  <font face="symbol">»</font
> 17%
of procedure interfaces were defective.</li>
<p>
<li> Programs are less than 100% portable because of a few remaining
platform-dependent features.</li>
<p>
<li> Control structures are poor, so it hard to avoid using
<tt>GOTO</tt>s and labels, often leading to spaghetti code.</li>
<p>
<li> Archaic features left over from the punched-card era:

<ul><p>
<li> fixed-format lines,</li>
<p>
<li> statements all in upper-case,</li>
<p>
<li> variable names limited to 6-characters.</li>
</ul></li>
<p>
<li> In practice programmers are driven to use extensions to 
Fortran77 Standard - which reduce portability.</li>
</ul>

<p>
     <h3><a name="tth_sEc1.2">
1.2</a>&nbsp;&nbsp;What's New in Fortran90</h3>

<p>

<ul><p>
<li> <b>Free-format source code</b> and many other simple improvements.</li>
<p>
<li> <b>Arrays as first-class objects</b>, whole-array expressions,
assignments, and functions.</li>
<p>
<li> <b>Dynamic memory allocation</b>; pointers to allow complex
dynamic data structures to be constructed.</li>
<p>
<li> <b>User-defined data types</b>; existing operators can be 
overloaded (re-defined) or new ones defined.</li>
<p>
<li> <b>The MODULE</b> - a new program unit which can encapsulate data and
a related set of procedures (subroutines or functions).  Can implement classes
and member functions for object-oriented programming.</li>
<p>
<li> <b>New control structures</b>:
<tt>SELECT CASE</tt>, <tt>CYCLE</tt>, and <tt>EXIT</tt> so labels and explicit jumps are 
rarely needed.</li>
<p>
<li> Recursive functions, generic names for procedures, 
optional arguments, calls with keywords, and many other procedure call
options.</li>
</ul>

<p>
     <h3><a name="tth_sEc1.3">
1.3</a>&nbsp;&nbsp;Benefits</h3>

<p>

<ul><p>
<li> Programs often <b>simpler</b>, and thus easier to maintain.</li>
<p>
<li> Programs are <b>safer</b> and more reliable because the compiler can detect 
many more mistake (provided sensible safety features are used).</li>
<p>
<li> Programs <b>more portable</b>, because very few machine-dependant features
remain, and there is little need to use extensions.</li>
<p>
<li> <b>Parallel processing</b> supported by whole array operations and
other features.</li>
<p>
<li> Fortran77 is a true subset: nothing has been taken out.  You can
adopt the new features gradually.</li>
</ul>

<p>
     <h3><a name="tth_sEc1.4">
1.4</a>&nbsp;&nbsp;Will old code still work?</h3>

<p>
<b>Yes</b> - if it used only Standard Fortran77 or extensions which are now
part of Fortran90.

<p>
<b>But</b> common extensions to Fortran77 which were <b>not</b> 
included in Fortran90 include:

<p>

<ul><p>
<li> Tab-formatted source-code lines - change tabs to spaces, maybe use
free-format.</li>
<p>
<li> Data type declarations like <tt>INTEGER*2</tt> 
and <tt>REAL*8</tt> - new syntax better but more complicated.</li>
<p>
<li> Hexadecimal, octal, and binary constants in expressions 
- allowed only in <tt>DATA</tt> statements.</li>
<p>
<li> VAX data structures - Fortran90 structures have different syntax.</li>
<p>
<li> Functions like <tt>%VAL</tt> in subprogram calls - the new 
dynamic memory facilities are much better.</li>
<p>
<li> Expressions in formats (e.g. <tt>FORMAT(F&lt;nw&#62;.3)</tt> - can do this
indirectly with internal-file I/O.</li>
<p>
<li> Some <tt>OPEN</tt> options such as <tt>ACCESS='APPEND'</tt> -  change to 
<tt>POSITION=&#196;PPEND"</tt>.</li>
</ul>

<p>
<b>Function name clashes</b> - Fortran has no reserved words, but problems
may arise one of your external function names matches that of an 
intrinsic function.   There are 75 new ones, and names to avoid now 
include: <tt>ALL</tt>, <tt>ANY</tt>, <tt>COUNT</tt>, <tt>HUGE</tt>, <tt>KIND</tt>, <tt>
MAXVAL</tt>, <tt>MERGE</tt>, <tt>MINVAL</tt>, <tt>PACK</tt>, <tt>RANGE</tt>, <tt>
SCALE</tt>, <tt>SCAN</tt>, <tt>SIZE</tt>, <tt>SUM</tt>, <tt>TRIM</tt>, and <tt>
UNPACK</tt>.   This problem can be avoided by declaring your function to be
<tt>EXTERNAL</tt> wherever necessary.

<p>
<b>Static storage assumption</b> - Fortran77 compilers generally used
static storage for all variables, so <tt>SAVE</tt> statements could be omitted
with impunity.  Most Fortran90 systems use static storage only when
required (variables given an initial value, or has an
explicit <tt>SAVE</tt> attribute).  Otherwise local variables in
subprograms will not be preserved after control returns, and missing
<tt>SAVE</tt> statements may cause problems.

<p>
     <h3><a name="tth_sEc1.5">
1.5</a>&nbsp;&nbsp;Fortran90 Compilers</h3> 

<p>
Wide choice for PC/Windows and most Unix platforms, one or two for
PC/Linux, VMS and Macintosh. They tend to be more expensive than for
Fortran77, and not all are as efficient or stable.  

<p>
The following are available free:

<ul><p>
<li> F for Linux is another subset, free for Linux from Imagine1
<tt>http://www.imagine1.com/imagine1</tt></li>
<p>
<li> A translator from Fortran90 to Fortran77 can be obtained free for
Linux from Pacific-Sierra Research <b>http://www.psrv.com</b> (but
it has many limitations).</li>
</ul>
The subsets supported by ELF90 and F are slightly different: both support
all the  modern features of Fortran90 and leave out all the obsolete stuff, so
they are not suitable for legacy code. 

<p>
GNU's free compiler, <tt>g77</tt>, is suitable for legacy code and runs on
many platforms, but supports only a few of the new features of
Fortran90.   

<p>
     <h3><a name="tth_sEc1.6">
1.6</a>&nbsp;&nbsp;The Future</h3>

<p>
<b>Fortran95</b> was formally adopted as the ISO Standard in November
1997.  It adds only a few new features (e.g.&nbsp;a way of specifying initial
values for data structures).  The first Fortran95 compilers have already
started to appear and many more are likely to appear by the end of 1998.

<p>
<b>Fortran2000</b> is currently being defined: major new features are likely to
include full support for object-oriented programming, and syntax for
inter-operability with C.

<p>
 <h2><a name="tth_sEc2">
2</a>&nbsp;&nbsp;New Look and Feel</h2>

<p>
Use of lower-case and long variable names already a common extention
to Fortran77; free-format
layout is a more radical change.

<p>
<i>Examples here will use</i> <tt>UPPER CASE</tt> <i>for
Fortran keywords and intrinsic functions,</i> <tt>lower case</tt>
<i>for user-chosen names.  This is not a recommended convention,
just for clarity in these notes</i>.

<p>
     <h3><a name="tth_sEc2.1">
2.1</a>&nbsp;&nbsp;Basic Rules for both free and fixed-format</h3> 

<p>
<b>Lower-case letters</b> may be used, but Fortran is case-insensitive
(except within  quoted character constants).

<p>
<b>Symbolic names</b> can be up to 31 characters long, and names may include
underscores as well as digits:

<pre>
      temperature_in_fahrenheit = temperature_in_celsius * 1.8 + 32.0

</pre>

<p>
<b>Semi-colons</b> separate two or more statements on the same line:

<pre>
      sumx = 0.0; sumy = 0.0; sumz = 0.0

</pre>

<p>
<b>End-of-line comments</b> start with an exclamation mark  (but must not be
in column 6 of fixed-format code).

<pre>
      nday = mjd(year, month, day)     ! convert to Modified Julian Date

</pre>      

<p>
<b>Character constants</b> may be enclosed either in a pair of apostrophes or
double-quote marks - making it easier to embed the other character in a
string:

<pre>
      WRITE(*,*) "If it ain't broke don't fix it"

</pre>

<p>
<b>Relational operators</b> may be given in old or new forms:

<p>

<center>
<table>
<tr><td>old form: </td><td align="center"><tt>.GE.</tt> </td><td align="center"><tt>.GT.</tt> </td><td align="center"><tt>.EQ.</tt> </td><td align="center"><tt>.NE.</tt> </td><td align="center"><tt>.LE.</tt> </td><td align="center"><tt>.LT.</tt> </td></tr>
<tr><td>new form: </td><td align="center"><tt>&#62;=</tt> </td><td align="center"><tt>&#62;</tt> </td><td align="center"><tt>==</tt> </td><td align="center"><tt>/=</tt> </td><td align="center"><tt>&lt;=</tt> </td><td align="center"><tt>&lt;</tt> </td></tr></table>

</center>

<p>
     <h3><a name="tth_sEc2.2">
2.2</a>&nbsp;&nbsp;Free-format layout</h3>

<p>

<ul><p>
<li> Free-format an alternative to column-based fixed-format.</li>
<p>
<li> Must choose either <b>free</b> or <b>fixed</b> format for each 
source file (rules differ).</li>
</ul>
Most compilers assume <b>free-format</b> if the source file  has an
extension of <tt>.f90</tt>  and <b>fixed-format</b> otherwise (but usually one
can over-ride this with  command-line switches such as <tt>-free</tt> and
<tt>-fixed</tt>). 

<p>
<b>Free-format layout rules:</b>

<ol type="1"><p>
<li> <b>Statements</b> may appear anywhere on a line; lines may be up to 132
characters long.</li>
<p>
<li> <b>Comments</b> start with an exclamation mark ``<tt>!</tt>'' (so <tt>C</tt>
or <tt>*</tt> in column 1 have to be changed to ``<tt>!</tt>'').</li>
<p>
<li> <b>To continue a statement</b> put an ampersand ``<tt>&amp;</tt>''
at the end of each incomplete line:

<p>

<pre>
  CALL predict( mercury, venus, earth, &amp;     ! comment allowed here
                mars, jupiter, saturn, uranus, neptune, pluto)

</pre>
If the line-break splits a name or constant then a comment is not allowed, 
and the next line must start with another ampersand:

<pre>
  WRITE(*,*) "University of Leicester, Department of &amp;
             &amp;Physics &amp; Astronomy"         ! NO comment on preceding line

</pre></li>
<p>
<li> <b>Spaces are significant</b> in free-format code:  embedded spaces
are not allowed in variable names or constants, but a space is generally
required between two successive words (but they are optional in some
two-word Fortran terms including <tt>DOUBLE PRECISION</tt>, <tt>ELSE IF</tt>,
<tt>GO TO</tt>, <tt>END DO</tt>, and <tt>END IF</tt>).

<pre>
      MILLION = 1 000 000   ! valid in fixed-layout lines only

</pre></li>
</ol>

<p>
With care one can write code valid in both formats, which may be useful
for  INCLUDE files to be used in both old and new code: the secret for
continuation lines is to put an ampersand after column 72 and another  in
column 6 of the next line. 

<p>
     <h3><a name="tth_sEc2.3">
2.3</a>&nbsp;&nbsp;New Forms for Specification Statements</h3>

<p>
<tt>IMPLICIT NONE</tt> is now standard (and recommended so the compiler
flags more mistakes). 

<p>
The <tt>DOUBLE PRECISION</tt> data type is now just a special case of <tt>
REAL</tt> so all facilities are identical; this means that double-precision 
complex is fully standardised. 

<p>
<tt>INCLUDE</tt> statements are also standard (but the <tt>MODULE</tt> 
now provides better facilities). 

<p>
<b>Type statements</b> - new form with double-colon allows 
all attributes of variables to be specified at once:

<pre>
  INTEGER, DIMENSION(800,640) :: screen, copy, buffer

</pre>

<p>
<b>Define constants</b> without separate <tt>PARAMETER</tt>
statement:

<pre>
  REAL, PARAMETER :: pi = 3.14159, rtod = 180.0/pi

</pre>

<p>
<b>Initialise variables</b> too: 

<pre>
  CHARACTER(LEN=50) :: infile = "default.dat"
  INTEGER :: file_number = 1, error_count = 0

</pre>

<p>
<tt>DATA</tt> statement almost redundant - still useful to 
initialise just part of an array, use a repeat-count, or a hexadecimal
constant:

<pre>
  INTEGER :: dozen(12), forty_two, sixty_three, max_byte
  DATA dozen / 6*0, 6*1 /, forty_two / B'101010' /,      &amp;
       sixty_three / O'77' /, max_byte / Z'FF'/

</pre>

<p>
<b>The</b> <tt>SAVE</tt> <b>attribute</b> is applied automatically to any variable given an
initial value, whether in a <tt>DATA</tt> or type statement.

<p>
<tt>INTENT</tt> may be specified for procedure arguments: useful
aid to documentation, and allows the compiler to check usage more carefully:

<pre>
   SUBROUTINE readfile(iounit, array, status)
   IMPLICIT NONE                    ! not essential but good practice
   INTEGER, INTENT(IN)    :: iounit ! unit number to read from
   REAL, INTENT(OUT)      :: array  ! data array returned
   INTEGER, INTENT(INOUT) :: status ! error-code (must be zero on entry)

</pre>

<p>
 <h2><a name="tth_sEc3">
3</a>&nbsp;&nbsp;New Control Structures</h2>

<p>
     <h3><a name="tth_sEc3.1">
3.1</a>&nbsp;&nbsp;The <tt>SELECT CASE</tt> Structure</h3>
<tt>SELECT CASE</tt> replaces the computed <tt>GO TO</tt> which required a
plethora of statement labels.  The new structure is often easier to use and
more efficient than a set of <tt>ELSE IF</tt> clauses and is label-free. 
The example below, given a day-number between 1 and 31, selects a suitable 
suffix, e.g.&nbsp;to turn ``<tt>3</tt>'' into ``<tt>3rd</tt>'', etc.:

<p>

<pre>
  SELECT CASE(day_number)
  CASE(1, 21, 31)
     suffix = 'st'
  CASE(2, 22)
     suffix = 'nd'
  CASE(3, 23)
     suffix = 'rd'
  CASE(4:20, 24:30)
     suffix = 'th'
  CASE DEFAULT
     suffix = '??'
     WRITE(*,*)'invalid date: ', day_number
  END SELECT
  WRITE(*, "(I4,A2)") day_number, suffix

</pre>

<p>
The selection expression may be of integer or character type; the ranges in
each <tt>CASE</tt> statement must not overlap.  The default clause is
optional.

<p>
     <h3><a name="tth_sEc3.2">
3.2</a>&nbsp;&nbsp;<tt>DO</tt>, <tt>EXIT</tt> and <tt>CYCLE</tt> statements</h3>

<p>
The <tt>END DO</tt> statement is at last part of the Standard, so
a label is no longer needed in each <tt>DO</tt> statement.  In addition <tt>
CYCLE</tt> will cause the next iteration to start at once, while <tt>EXIT</tt>
exits the loop structure prematurely.

<p>
This example scans the headers of a FITS file:

<pre>
  CHARACTER(LEN=80) :: header
  DO line = 1,36
    READ(unit, "(a80)") header
    IF( header(1:8) == "COMMENT") THEN   ! ignore comments - loop again
      CYCLE                              
    ELSE IF( header(1:8) == "END") THEN  ! need READ no more lines
      EXIT                               ! so exit from the loop
    ELSE
! process this header...
  END DO

</pre>

<p>
An <b>indefinite</b> <tt>DO</tt> also exists - here an
<tt>EXIT</tt> from the loop is essential:

<pre>
  sum  = 0.0
  DO
    READ(*, IOSTAT=status) value
    IF(status /= 0) EXIT
    sum = sum + value                ! or whatever
  END DO

</pre>

<p>
     <h3><a name="tth_sEc3.3">
3.3</a>&nbsp;&nbsp;<tt>DO WHILE</tt> statement</h3>

<p>
<tt>DO WHILE</tt> is supported, but an indefinite DO with an <tt>EXIT</tt> 
does much the same: 

<pre>
   DO WHILE( ABS(x - xmin) &#62; 1.0e-5) 
      CALL iterate(x, xmin)
   END DO

</pre>

<p>
     <h3><a name="tth_sEc3.4">
3.4</a>&nbsp;&nbsp;Structure Names</h3>

<p>
<b>Names</b> may be given to <tt>DO</tt>-loops, <tt>IF</tt>-blocks, or 
<tt>CASE</tt>-structures - helps readability when they are deeply
nested, and required to <tt>EXIT</tt> from (or <tt>CYCLE</tt> around)
anything other than the innermost loop.

<p>

<pre>
        sum = 0.0
outer:  DO j = 1,ny              ! sum values until zero encountered
inner:     DO i = 1,nx
              IF(array(i,j) == 0.0) EXIT outer
              sum = sum + array(i,j)
           END DO inner
        END DO outer

</pre>           
Note that structure names like <tt>inner</tt> do not have the drawbacks of
statement labels because it is not possible to jump to them using a <tt>GO
TO</tt> statement.

<p>
     <h3><a name="tth_sEc3.5">
3.5</a>&nbsp;&nbsp;Label-free programming</h3>

<p>
<b>Statement labels</b> should be avoided because each one marks the site 
of a jump from elsewhere, and thus makes it harder to see the execution
sequence.  Label-free programming is now feasible in many cases:

<p>

<ol type="1"><p>
<li> <tt>DO</tt>-loops with <tt>END DO</tt> no longer need labels, and
error-handling can mostly use <tt>EXIT</tt> or <tt>RETURN</tt>.</li>
<p>
<li> Computed-<tt>GO TO</tt> should be replaced by <tt>SELECT CASE</tt>.</li>
<p>
<li> <tt>FORMAT</tt> statements can be replaced by a format string
in the <tt>READ</tt> or <tt>WRITE</tt>
statement itself, e.g.:

<pre>
  WRITE(unit, "(A,F10.3,A)") "flux =", source_flux, " Jansky"

</pre></li>
</ol>

<p>
     <h3><a name="tth_sEc3.6">
3.6</a>&nbsp;&nbsp;Internal Procedures</h3>

<p>
Generalisation of statement functions - no longer
limited to one line:

<p>

<pre>
   SUBROUTINE polygon_area(vertices)    ! an external procedure
   IMPLICIT NONE                        ! applies throughout
!...
      area1 = triangle_area(a, b, x)
!...
      area2 = triangle_area(x, c, d)
!...
   CONTAINS                 ! internal procedures follow...
      REAL FUNCTION triangle_area(a, b, c)  ! internal procedure
      REAL, INTENT(IN) :: a, b, c
      REAL :: s             ! local variable in the function
         s = 0.5 * (a + b + c) 
         triangle_area = sqrt(s * (s-a) * (s-b) * (s-c))
      END FUNCTION triangle_area
   END SUBROUTINE polygon_area

</pre>

<p>
Rules for internal procedures:

<ul><p>
<li> May be subroutines or functions</li>
<p>
<li> Placed within <b>host</b> program unit after <tt>CONTAINS</tt>
statement (which ends executable code of host).</li>
<p>
<li> A host may have any number of internal procedures, which may
call one another (but may not be nested).</li>
<p>
<li> Need <tt>END SUBROUTINE</tt> or <tt>END FUNCTION</tt> at the end
- appending the procedure name is optional.</li>
</ul>
<b>Host association</b>: internal procedures may access  to all
the host's variables (unless they declare local variables with the
same name) but not vice-versa.

<p>
Host association has its risks: e.g.&nbsp;using a variable <tt>
x</tt> in the internal procedure (above) without declaring  it would 
inadvertently use the host's <tt>x</tt>.

<p>
May use scoping rules to set up set of procedures with a few global
variables, e.g.

<pre>
   SUBROUTINE main(args)
   REAL :: args               !accessible to internal procedures
   REAL :: global_variables   ! likewise
   CALL internal
   CONTAINS
     SUBROUTINE internal
     !...
     END SUBROUTINE internal
     SUBROUTINE lower_level
     !...
     END SUBROUTINE lower_level
   END SUBROUTINE main

</pre>

<p>
 <h2><a name="tth_sEc4">
4</a>&nbsp;&nbsp;Arrays</h2>

<p>
     <h3><a name="tth_sEc4.1">
4.1</a>&nbsp;&nbsp;Declaring and Initialising Arrays</h3>

<p>
New form of type statement with double colon can declare arrays and
simple scalars:

<pre>
   REAL :: array(3,4,5), scalar, vector(12345)

</pre>
Dimension attribute useful if several arrays have the same shape:

<pre>
  INTEGER, DIMENSION(1024,768) :: screen, window, new_window

</pre>

<p>
An <b>Array constant</b> is a list of elements enclosed in <tt>(/</tt> and
<tt>/)</tt> and may be used to give an initial value to a variable or to
define an array constant.

<pre>
  INTEGER :: options(3) = (/ 5, 10, 20 /)           ! initial values
  CHARACTER(LEN=3), PARAMETER :: day(0:6) = &amp;
     (/'Sun','Mon','Tue','Wed','Thu','Fri','Sat'/)  ! array constant

</pre>

<p>
<b>Array terminology</b>: 
An array declared like this:

<pre>
   REAL :: X(2,5,-1:8)

</pre>
has a <b>rank</b> of 3, <b>extents</b> of 2, 5, and 10, a
<b>shape</b> of <tt>(/ 2, 5, 10 /)</tt>, and a <b>size</b> of 100.

<p>
     <h3><a name="tth_sEc4.2">
4.2</a>&nbsp;&nbsp;Array-valued expressions and assignments</h3>

<p>
Arrays are now first-class objects, and array-valued expressions are
evaluated element-wise, which saves writing many simple loops:

<pre>
  REAL, DIMENSION(512,1024) :: raw, background, exposure, result, std_err
!...
  result  = (raw - background) / exposure   

</pre>
Similarly all appropriate intrinsic functions operate element-wise if
given an array as their argument:

<pre>
  std_err = SQRT(raw) / exposure            

</pre>
<b>Array expressions</b> may also include <b>scalar</b> constants
and variables:  these are effectively replicated (or expanded) to
the required number of elements:

<pre>
  std_err    = 0.0                       ! every element set to zero
  background = 0.1 * exposure + 0.125

</pre>
All the elements in an array-valued expression must be <b>conformable</b>,
that is they are either either scalars or arrays all of which have the
same <b>shape</b>, i.e.&nbsp;the same number of elements along each axis
(the actual lower and upper-bounds may be different).

<p>
     <h3><a name="tth_sEc4.3">
4.3</a>&nbsp;&nbsp;Array Constructors</h3>

<p>
An <b>array constructor</b>, which is generalisation of the array constant,
may appear in any array expression, and  and may contain a list of
scalars, arrays, or loops:

<pre>
  array = (/ 1.51, x, 2.58, y, 3.53 /)    
  ramp  = (/ (REAL(i), i = 1,10) /)

</pre>

<p>
The array constructor only works for 1-dimensional arrays.  For arrays of
higher rank the <tt>RESHAPE</tt> function is useful: its
second argument specifies the <b>shape</b>  of the output array:

<pre>
  INTEGER :: list(2,3) = RESHAPE( (/ 11, 12, 21, 22, 31, 32 /), (/2,3/))

</pre>

<p>
     <h3><a name="tth_sEc4.4">
4.4</a>&nbsp;&nbsp;Array Sections</h3>

<p>
An <b>array section</b> or slice is specified with a colon separating the
lower and upper bounds.  Thus <tt>ramp(7:9)</tt> is a 3-element slice  of
array <tt>ramp</tt>.  Similarly <tt>raw(2:101,301:500)</tt> is a slice of the
array called <tt>raw</tt> of shape 100 &times; 200 elements.  Note that a
slice does not have to occupy contiguous storage locations - Fortran
takes care of this.  It also allows assignments statements involving
overlapping slices: 

<pre>
  a(2:10) = a(1:9)    ! shift up one element
  b(1:9)  = b(3:11)   ! shift down two elements

</pre>
In such cases the compiler must generate code to work through the elements
in the right order (or copy to some temporary space) to avoid overwriting.

<p>
<b>Array triplet notation</b> allows sparse sub-arrays to be selected;
the <b>stride</b> (third item in the triplet) must not of course be zero:

<pre>
  b(1:10:2)    ! selects five elements: 1, 3, 5, 7, 9
  b(90:80:-3)  ! selects four elements 90, 87, 84, 81 in that order

</pre>

<p>
<b>Zero-sized arrays</b> may be referenced, just as if a DO-loop had been
used which specified no iterations.  Thus <tt>b(k:n)</tt> has no
elements if <tt>k</tt> is greater than <tt>n</tt>.  

<p>
<b>Vector subscripts</b> may also be used: 

<pre>
  INTEGER :: mysub(4)
  REAL    :: vector(100)
  mysub = (/ 32, 16, 17, 18 /)
  WRITE(*,*) vector(mysub)

</pre>
This outputs only elements 32, 16, 17, and 18 of the vector in that order.

<p>
Note that <b>vector subscripts</b> may only be used on the left-hand side
of an assignment if there are no repeated values in the list of subscripts
(otherwise one element would have to be set to  two different values).

<p>
     <h3><a name="tth_sEc4.5">
4.5</a>&nbsp;&nbsp;Array Intrinsic Functions</h3>
Arguments in <i>italics</i> are optional.

<p>
<b>Array reduction functions</b>

<p>

<center>
<table>
<tr><td><tt>l = ALL(mask, <i>dim</i>) </tt> </td><td>.true. if all elements are true </td></tr>
<tr><td><tt>l = ANY(mask, <i>dim</i>)</tt> </td><td>.true. if any elements are true </td></tr>
<tr><td><tt>i = COUNT(mask, <i>dim</i>)</tt> </td><td>Number of true elements </td></tr>
<tr><td><tt>x = SUM(array, <i>dim, mask</i>)</tt> </td><td>Sum of elements </td></tr>
<tr><td><tt>x = PRODUCT(array, <i>dim, mask</i>)</tt> </td><td>Product of elements </td></tr>
<tr><td><tt>x = MAXVAL(array, <i>dim, mask</i>)</tt> </td><td>Maximum value in array </td></tr>
<tr><td><tt>x = MINVAL(array, <i>dim, mask</i>)</tt> </td><td>Minimum value in array </td></tr>
<tr><td><tt>x = DOT_PRODUCT(va, vb)</tt> </td><td>Dot product of two vectors </td></tr></table>

</center>

<p>
Example: if <b>REAL :: myarray(2,3)</b> contains

<table>
<tr><td align="center"></td><td align="center">1 </td><td align="center">3 </td><td align="center">5 </td></tr>
<tr><td align="center">myarray </td></tr>
<tr><td align="center"></td><td align="center">2 </td><td align="center">4 </td><td align="center">6 </td></tr></table>


<p>
<tt>SUM(myarray)</tt> returns <tt>21</tt> <br />
<tt>SUM(myarray, DIM=1)</tt> returns <tt> (/ 9, 12 /) </tt>
<tt>SUM(myarray, DIM=2)</tt> returns <tt> (/ 3, 7, 11/)</tt> <br />

<p>
<b>Other array manipulation functions</b>

<p>

<center>
<table>
<tr><td><tt>a = MATMUL(mata, matb)</tt>   </td><td>Matrix multiplication (or matrix X
vector)</td></tr>
<tr><td><tt>a = TRANSPOSE(matrix)</tt> </td><td>Transpose of 2-d array </td></tr>
<tr><td><tt>a = CSHIFT(array, shift, <i>dim</i>)</tt> </td><td>Circular shift of elements </td></tr>
<tr><td><tt>a = EOSHIFT(array, shift, <i>dim</i>)</tt> </td><td>End-off shift of elements </td></tr>
<tr><td><tt>a = PACK(array, mask, <i>pad</i>)</tt> </td><td>Pack values of array
which pass the mask </td></tr>
<tr><td><tt>a = MERGE(tsource, fsource, mask)</tt> </td><td>Use tsource if mask is
true, else fsource elements. </td></tr>
<tr><td><tt>a = MAXLOC(array, <i>mask</i>)</tt> </td><td>Location of maximum element </td></tr>
<tr><td><tt>a = MINLOC(array, <i>mask</i>)</tt> </td><td>Location of minimum element </td></tr></table>

</center>
Note: <tt>MAXLOC</tt> and <tt>MINLOC</tt> used on a 1-d array return an 
array of one element, which is not the same as a scalar.

<p>
An example of their use is to find the mean and variance of an array but
with values of zero to be ignored:

<pre>
  mean = SUM(x /= 0.0) / COUNT(x /= 0.0)
  variance = SUM((x-mean)**2, MASK= x /= 0.0) / COUNT(x /= 0.0)

</pre>

<p>
     <h3><a name="tth_sEc4.6">
4.6</a>&nbsp;&nbsp;<tt>WHERE</tt> structure</h3>
When some elements of an array expression have to be treated specially, the
<tt>WHERE</tt> structure may be useful:

<pre>
  WHERE(x /= 0.0)
    inverse = 1.0 / x
  ELSEWHERE
    inverse = 0.0
  END WHERE

</pre>
There is also a single statement form of it:

<pre>
  WHERE(array &#62; 100.0) array = 0.0

</pre>

<p>
 <h2><a name="tth_sEc5">
5</a>&nbsp;&nbsp;Dynamic Storage</h2>

<p>
There are three forms of dynamic array: automatic, allocatable, and pointer
array.

<p>
     <h3><a name="tth_sEc5.1">
5.1</a>&nbsp;&nbsp;Automatic Arrays</h3>
An <b>automatic array</b> is a local array in a procedure which has its 
size set when the procedure is called: 

<pre>
   SUBROUTINE smooth(npts, spectrum)
   IMPLICIT NONE
   INTEGER, INTENT(IN) :: npts
   REAL, INTENT(INOUT) :: spectrum
   REAL :: space(npts), bigger(2*npts)  ! automatic arrays

</pre>
The dimension bounds may be integer expressions involving any variables
accessible at that point: normally this means other arguments of the
routine. Within the procedure an automatic array is just like any other;
it may be passed to lower-level routines, but it becomes undefined as
soon as control returns to above the level at which it is defined. 
An automatic array cannot be defined initially or be used
to save values from one call to another.

<p>
Most systems store automatic arrays on the stack; some Unix systems 
do not allocate much stack space by default.  The following command may be
used to increase it: 

<pre>
&#62;  limit stack unlimited

</pre>

<p>
     <h3><a name="tth_sEc5.2">
5.2</a>&nbsp;&nbsp;Allocatable Arrays</h3>
<b>Allocatable arrays</b> are more generally useful as their size may be set
at any point.  
Only the rank has to be
declared in advance, with a colon marking the each dimension:

<pre>
  REAL, ALLOCATABLE :: vector(:), matrix(:,:), three_d(:,:,:)

</pre>
The actual dimension bounds may then be set anywhere in the executable
code (the lower bound is 1  by default):

<pre>
  ALLOCATE(vector(12345), matrix(0:511,0:255))

</pre>
Allocatable arrays may be passed to lower-level routines in the usual way. 
But they need to be explicitly deallocated before the procedure which
declares them exits, otherwise a <b>memory leak</b> may occur.  

<pre>
  DEALLOCATE(matrix, vector) 

</pre>
Once a its size has been allocated, it cannot be altered,  except by
deallocating the array and then allocating it again.  If you want to
preserve the contents they need to be copied somewhere else temporarily.

<p>
Most systems use heap storage for allocatable arrays.  With very large
arrays one might use up all the space available, so a status variable
can be used to check. It normally returns zero, but is set non-zero if the
allocation fails:

<pre>
  ALLOCATE(huge_array(1:npts), STAT=ierror)
  IF(ierror /= 0) THEN
     WRITE(*,*)"Error trying to allocate huge_array"
     STOP 
  END IF

</pre>
In such cases there may be another less memory-intensive algorithm
available, otherwise the program should exit gracefully.

<p>
It is important to ensure that you do not attempt to allocate the same
array twice; the <tt>ALLOCATED</tt> intrinsic function helps here:

<pre>
   IF(ALLOCATED(myarray)) THEN
       DEALLOCATE(myarray)
   END IF
   ALLOCATE(myarray(1:newsize))

</pre>

<p>
An allocatable array can also be declared to have the <tt>SAVE</tt> attribute,
in which case it will survive after the exit of the procedure which creates
it.   This is especially useful in connection with modules (as explained
later).

<p>
     <h3><a name="tth_sEc5.3">
5.3</a>&nbsp;&nbsp;Pointer arrays</h3>

<p>
An allocatable array cannot be passed to a procedure when in an
un-allocated state.  But this can be done with a pointer array:

<pre>
   PROGRAM pdemo
   IMPLICIT NONE
   REAL, POINTER :: parray(:)
     OPEN(UNIT=9, FILE='mydata', STATUS='old')
     CALL readin(9, parray)
     WRITE(*,*)'array of ', SIZE(array), ' points:'
     WRITE(*,*) parray
     DEALLOCATE(parray)
     STOP                       ! STOP is optional
   CONTAINS
      SUBROUTINE readin(iounit, z)
      INTEGER, INTENT(IN) :: iounit
      REAL, POINTER       :: z(:)     ! cannot use INTENT for pointer
         INTEGER :: npoints
         READ(iounit) npoints         ! find how many points to read
         ALLOCATE(z(1:npoints))       ! allocate the space
         READ(iounit) z               ! read the entire array
      END SUBROUTINE readin
   END PROGRAM pdemo

</pre>

<p>
This example is especially simple because an internal procedure is used, so
that the compiler knows all the details of the interface when it compiles
the subroutine call: a so-called <b>explicit interface</b>, which is
required when passing a pointer to a procedure.

<p>
 <h2><a name="tth_sEc6">
6</a>&nbsp;&nbsp;Modules and Interfaces</h2>

<p>
The there are now four types of program unit in Fortran:

<p>

<ol type="1"><p>
<li> Main program - should start with a main <tt>PROGRAM</tt> statement.</li>
<p>
<li> External procedures (subprograms) - start with <tt>SUBROUTINE</tt> or
<tt>FUNCTION</tt> statement.</li>
<p>
<li> Block data subprograms (now superseded along with common
blocks) - starts with <tt>BLOCK DATA</tt> statement.</li>
<p>
<li> Module - starts with <tt>MODULE</tt> statement.</li>
</ol>

<p>
The <b>module</b> may contain any combination of:

<ul><p>
<li> definitions of constants</li>
<p>
<li> definitions of derived types (data structures)</li>
<p>
<li> data storage declarations</li>
<p>
<li> procedures (subroutines and functions)</li>
</ul>

<p>
The module may be accessed with a <tt>USE</tt> statement in any other program
unit (including another module).

<p>
     <h3><a name="tth_sEc6.1">
6.1</a>&nbsp;&nbsp;Example defining constants</h3>

<p>

<pre>
   MODULE trig_consts
   IMPLICIT NONE
      DOUBLE PRECISION, PARAMETER :: pi = 3.141592653589d0, &amp;
           rtod = 180.0d0/pi, dtor = pi/180.0d0
   END MODULE trig_consts

   PROGRAM calculate
   USE trig_consts
   IMPLICIT NONE
      WRITE(*,*) SIN(30.0*dtor)
   END PROGRAM calculate

</pre>

<p>
Note that:

<ul><p>
<li> <tt>USE</tt> statements always precede all other types of specification
statement, even <tt>IMPLICIT NONE</tt>.</li>
<p>
<li> The module must be compiled <b>before</b> all other program units
which use it; it may be in the same file or a separate file.  Most
compilers support separate compilation, and leave a <tt>.mod</tt> file, or
something similar, containing the module information for the use of
subsequently encountered <tt>USE</tt> statements.</li>
</ul>

<p>
These simple uses of the module barely distinguish it from an <tt>
INCLUDE</tt> file (now part of the Fortran Standard), but the module is
actually a much more powerful facility, because of module
procedures.

<p>
     <h3><a name="tth_sEc6.2">
6.2</a>&nbsp;&nbsp;Module Procedures</h3>

<p>
The general structure of a module:

<ol type="1"><p>
<li> starts with a data section</li>
<p>
<li> then has a  <tt>CONTAINS</tt> statement (if any procedures follow)</li>
<p>
<li> any number of module procedures follow.</li>
</ol>

<p>
Module procedures have direct access to all the
definitions and data storage in the data section via <b>host
association</b>.

<p>
Allows encapsulation of data and a set of procedures
which operate on the data or use the storage area for inter-communication.  

<p>
This (slightly shortened) module handles output to
a VT terminal or X-term window:

<p>

<pre>
MODULE vt_mod
  IMPLICIT NONE                ! applies to whole module
  CHARACTER(1), PARAMETER :: escape = achar(27)
  INTEGER, SAVE :: screen_width = 80, screen_height = 24
CONTAINS
  SUBROUTINE clear  ! Clears screen, moves cursor to top left
    CALL vt_write(escape // "[H" // escape // "[2J")
  END SUBROUTINE clear

  SUBROUTINE set_width(width)    ! sets new screen width
  INTEGER, INTENT(IN) :: width      ! preferred width (80/132)
    IF(WIDTH &#62; 80) THEN             ! switch to 132-column mode
      CALL vt_write( escape // "[?3h" )
      screen_width = 132
    ELSE                            ! switch to 80-column mode
      CALL vt_write( escape // "[?3l" )
      screen_width = 80
    END IF
  END SUBROUTINE set_width

  SUBROUTINE get_width(width)   ! returns screen width (80/132)
  INTEGER, INTENT(OUT) :: width
     width = screen_width
  END SUBROUTINE get_width

  SUBROUTINE vt_write(string)      ! for internal use only
  INTEGER, INTENT(IN) :: string
     WRITE(*, "(1X,A)", ADVANCE="NO") string
  END SUBROUTINE vt_write
END MODULE vt_mod


</pre>
To use this module one just needs at the top:

<pre>
   USE vt_mod

</pre>

<p>
     <h3><a name="tth_sEc6.3">
6.3</a>&nbsp;&nbsp;Public and Private accessibility</h3>

<p>
By default all module variables are available by all program units which
<tt>USE</tt> the module.  This may not always be desirable: if the module
procedures provide all the access functions necessary, it is safer if
package users cannot interfere with its internal workings.  By default all
names in a module are <tt>PUBLIC</tt> but this can be changed using the
the <tt>PRIVATE</tt> statement: 

<pre>
   MODULE vt_mod
      IMPLICIT NONE
      PRIVATE         ! change default so all items private
      PUBLIC  :: clear_screen, set_width, get_width

</pre>

<p>
Now a program unit which uses the module will not be able to access the
subroutine <tt>vt_write</tt> nor variables such as <tt>screen_width</tt>.

<p>
     <h3><a name="tth_sEc6.4">
6.4</a>&nbsp;&nbsp;Avoiding name clashes</h3>

<p>
Even with the precautions suggested above, sometimes a module will contain
a procedure (or variable) name which clashes with one that the user has
already chosen.  There are two easy solutions.  If the name is one that is
not actually used but merely made available by the module, then
the <tt>USE ONLY</tt> facility is sufficient:

<pre>
   USE vt_mod, ONLY: clear_screen

</pre>
But supposing that one needs access to two procedures both called <tt>
get_width</tt>,  the one accessed in the <tt>vt_mod</tt> module can be renamed:

<pre>
   USE vt_mod, gwidth =&#62; get_width

</pre>
so it acquires the temporary alias of <tt>gwidth</tt>.

<p>
     <h3><a name="tth_sEc6.5">
6.5</a>&nbsp;&nbsp;Pros and Cons of Modules</h3>

<p>

<ul><p>
<li> Modules can be used to encapsulate a data structure and the set of
procedures which manipulate it - or a class and its methods in OO-speak.</li>
<p>
<li> When a module procedure is called it is said to have an 
<b>explicit interface</b>  - this means that the compiler can check actual
and dummy arguments for consistency.  This is a very valuable feature,
since in Fortran77 such interfaces cannot usually be checked and errors are
common.</li>
<p>
<li> The module supersedes common blocks, <tt>BLOCK DATA</tt> and <tt>ENTRY</tt> 
statements.</li>
<p>
<li> Modules provide an additional structural level in program design:
   
<ol type="1"><p>
<li> Program</li>
<p>
<li> Modules</li>
<p>
<li> Procedures</li>
<p>
<li> Statements.</li>
</ol></li>
<p>
<li> The explicit interfaces which come automatically with module
procedures allow a range of advanced features to be used, including:
assumed-shape arrays, pointer arrays, optional arguments, functions
returning arrays or pointers, user-defined operators, generic names.  These
will be described in detail later.</li>
</ul>

<p>
<b>But</b> there are a few potential drawbacks:

<p>

<ul><p>
<li> Each module has to be compiled before any other program unit which
uses it: this needs care and means that the main program has to be last
rather than first, as is traditional.</li>
<p>
<li> Changes to a module mean re-compilation of all units which use it:
this needs to be coded into <tt>make</tt> files, and can lead to slow
compiles.</li>
<p>
<li> Usually a module compiles into a single object module, so that
reference to any procedure in a module causes all the code in the module to
be present into the executable program.</li>
</ul>

<p>
     <h3><a name="tth_sEc6.6">
6.6</a>&nbsp;&nbsp;Explicit Interfaces</h3>
An explicit interface is one where the dummy arguments of the procedure are
visible to the compiler when compiling the procedure call.  Explicit
interfaces are needed for a variety of advanced features.  An interface is
explicit:

<ul><p>
<li> When a module procedure is called from a program unit which uses it,
or from any other procedure of the same module.</li>
<p>
<li> When an internal procedure is called from its host or from any other
internal procedure of the same host.</li>
<p>
<li> A recursive procedure calls itself directly or indirectly.</li>
<p>
<li> Any intrinsic function is called.</li>
<p>
<li> An explicit <tt>INTERFACE</tt> block is provided.</li>
</ul>

<p>
Here is an example of an interface block:

<pre>
INTERFACE
   DOUBLE PRECISION FUNCTION sla_dat (utc)
      IMPLICIT NONE
      DOUBLE PRECISION :: utc
   END FUNCTION sla_dat

   SUBROUTINE sla_cr2tf (ndp, angle, sign, ihmsf)
      IMPLICIT NONE
      INTEGER :: ndp
      REAL    :: angle
      CHARACTER (LEN=*) :: sign
      INTEGER, DIMENSION (4) :: ihmsf
   END SUBROUTINE sla_cr2tf
END INTERFACE

</pre>
Note that an <tt>IMPLICIT NONE</tt> is needed in each procedure definition,
since an interface block inherits nothing from the enclosing module.

<p>
An interface block may, of course, be put in a module to facilitate use.
When using an existing (Fortran77) library, it may be worth-while to
create a module containing all the procedure interfaces - may be done
automatically using Metcalf's <tt>convert</tt> program.

<p>
 <h2><a name="tth_sEc7">
7</a>&nbsp;&nbsp;Procedures and Arguments</h2>

<p>
     <h3><a name="tth_sEc7.1">
7.1</a>&nbsp;&nbsp;Assumed shape arrays</h3>

<p>
The assumed-shape array is strongly recommended for all arrays passed to
procedures: the rank has to be specified, but the bounds are just marked 
with colons.  This means the actual shape is taken 
each time it is called from that of the corresponding actual argument.

<p>

<pre>
MODULE demo
IMPLICIT NONE
CONTAINS
   SUBROUTINE showsize(array)
   IMPLICIT NONE
   REAL, INTENT(IN) :: array(:,:)  ! 2-dimensional.
   WRITE(*,*) "array size", SIZE(array,1), " X ", SIZE(array,2)
   END SUBROUTINE showsize
END MODULE demo

PROGRAM asize
USE demo
IMPLICIT NONE
REAL :: first(3,5), second(123,456)
   CALL showsize(first)
   CALL showsize(second)
END PROGRAM asize

</pre>
The lower bound is one by default, it does not have to be the same as that
of the actual argument, as only the <b>shape</b> (extent along each axis) is
passed over, so that  intrinsic functions such as <tt>LBOUND</tt> and <tt>
UBOUND</tt> provide no additional information.

<p>
     <h3><a name="tth_sEc7.2">
7.2</a>&nbsp;&nbsp;Keyword calls and optional arguments</h3>

<p>
Any procedure which has an explicit interface, may be called using keyword
notation in the call, as an alternative to the positional notation.  All
intrinsic functions may also be called by keyword, which is handy when one
wants to omit optional arguments:

<pre>
   INTEGER :: intarray(8)
   CALL DATE_AND_TIME(VALUES=intarray)

</pre>

<p>
After any argument uses keyword notation, all subsequent ones
in same call must do so.

<p>
Arguments of user-written procedures may also be made optional, these
should be tested to see whether they are <tt>PRESENT</tt> before use:

<p>

<pre>
   SUBROUTINE write_text(string, nskip)
   CHARACTER(*), INTENT(IN) :: string      ! line of text
   INTEGER, INTENT(IN), OPTIONAL :: nskip  ! no of lines to skip
! local storage
   INTEGER :: localskip
   IF(PRESENT(nskip)) then
      localskip = nskip
   ELSE
      localskip = 0          ! default value
   END IF
! rest of code to skip lines etc.

</pre>

<p>
Optional arguments at the end of the list may simply be omitted in the
procedure call, but if you omit earlier ones you cannot simply use two
adjacent commas (as in some extensions to Fortran77).  After an optional
argument has been omitted, all subsequent arguments must use the keyword
notation.  

<p>
     <h3><a name="tth_sEc7.3">
7.3</a>&nbsp;&nbsp;Generic names</h3>

<p>
Intrinsic functions often have generic names, thus <tt>ABS</tt> does something
different depending on whether its argument is real, integer, or complex.
User-written functions may now be given a generic name in a similar way.

<p>
Suppose you have a module containing several similar data sorting routines,
for example <tt>sort_int</tt> to sort an array of integers, <tt>sort_real</tt>
to sort reals, etc.  A generic name such as <tt>sort</tt> may be declared in
the head of the module like this:

<pre>
  INTERFACE sort
     MODULE PROCEDURE sort_int, sort_real, sort_string
  END INTERFACE

</pre>

<p>
The rules for resolving generic names are complicated but it is sufficient
to ensure that each procedure differs from all others with the same
generic name in the <b>data type</b>, or <b>rank</b> of at least one
non-optional argument.

<p>
     <h3><a name="tth_sEc7.4">
7.4</a>&nbsp;&nbsp;Recursive procedures</h3>
Procedures may now call themselves directly or indirectly if declared to be
<tt>RECURSIVE</tt>.   Typical uses will be when handling self-similar data
structures such as directory trees, B-trees, quad-trees, etc.  The classical
example is that of computing a factorial:

<p>

<pre>
  RECURSIVE FUNCTION factorial(n) RESULT(nfact)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: n
  INTEGER :: nfact
  IF(n &#62; 0) THEN
     nfact = n * factorial(n-1)
  ELSE
     nfact = 1
  END IF
  END FUNCTION factorial

</pre>

<p>
But it is easy to see how to do this just as easily using a DO-loop.

<p>
The use of a <tt>RESULT</tt> variable is optional here, but required when the
syntax would otherwise be ambiguous, e.g.&nbsp;when the function returns an
array so an array element reference cannot be distinguished from a function
call.

<p>
 <h2><a name="tth_sEc8">
8</a>&nbsp;&nbsp;Derived Data Types (structures)</h2>

<p>
The terms <b>user-defined type</b>, and <b>data structure</b> and <b>
derived type</b> all mean the same thing.  A simple example is shown here,
designed to keep handle a list of celestial objects in an observing
proposal.  The first step is to define the structure:

<p>

<pre>
   TYPE :: target_type
      CHARACTER(15) :: name    ! name of object
      REAL ::          ra, dec ! celestial coordinates, degrees
      INTEGER ::       time    ! exposure time requested, secs
   END TYPE target_type

</pre>
Note that one can mix character and non-character items freely (unlike in
common blocks).  The compiler arranges the physical layout for efficient 
access.

<p>
This only specifies the structure: to create actual variables with 
this user-defined data type the <tt>TYPE</tt> statement is used in a different
form:

<pre>
   TYPE(target_type) :: old_target, new_list(30)

</pre>
This has created a structured variable, and an array of 30 elements, each of
which has the four specified components.  

<p>
     <h3><a name="tth_sEc8.1">
8.1</a>&nbsp;&nbsp;Accessing Components</h3> 

<p>
Components of a structure are accessed using per-cent signs
(unfortunately not dots as in many other languages, because of syntax
ambiguities). 

<p>
Thus <tt>old_target%name</tt> is a character variable,
while <tt>new_list(13)%ra</tt> is a real variable.  Such structure
components  can be used exactly like simple variables of the same data
type:

<p>

<pre>
    new_list(1)%name = "Cen X-3"
    new_list(1)%ra   = 169.758
    new_list(1)%dec  = -60.349
    new_list(1)%time = 15000
! .....
    new_list(2) = old_target      ! copy all components
    new_list(2)%time = 2 * new_list(2)%time 

</pre>
A space is optional either side of the per-cent sign.  Note also that
component names are local to the structure, so that there is no
problem if the same program unit also uses simple variables 
with names like <tt>name</tt>, <tt>ra</tt>, <tt>dec</tt> etc.

<p>
     <h3><a name="tth_sEc8.2">
8.2</a>&nbsp;&nbsp;Structure constructors</h3> 

<p>
These allow all the components of a structure to be set at once,  the
type-name is used as if it were a conversion function, with a list of the
component values as arguments:

<pre>
   new_list(3) = target_type("AM Her", 273.744, 49.849, 25000)

</pre>

<p>
If you have an array of some structured type, each component may be treated
as if it were an array: thus <tt>new_list%dec</tt> is an array of 30 real
values. The elements may not be in adjacent locations in memory, but the
compiler takes care of this:

<pre>
   total_time = SUM(new_list%time)

</pre>

<p>
Besides their use in assignment statements, structured variables 
can be used in input/output statements.  With unformatted or list-directed
I/O this is straight-forward, but with formatted I/O one has to 
provide an appropriate list of format descriptors:

<pre>
   WRITE(*,*) old_target        ! list-directed format easy
   READ(file, "(A,2F8.3,I6)") new_list(4)

</pre>

<p>
     <h3><a name="tth_sEc8.3">
8.3</a>&nbsp;&nbsp;Nested Structures</h3>

<p>
Two or more structure definitions may be <b>nested</b>:

<pre>
   TYPE :: point
      REAL :: x, y   ! coordinates
   END TYPE point

   TYPE :: line
      TYPE(point) :: end(2)   ! coordinates of ends
      INTEGER     :: width    ! line-width in pixels
   END TYPE line

   TYPE(line) :: v
   REAL       :: length
   v = line( (/ point(1.2,2.4), point(3.5,7.9) /), 2)
   length = SQRT((v%end(1)%x - v%end(2)%x)**2           &amp;
              +  (v%end(1)%y - v%end(1)%y)**2)

</pre>

<p>
     <h3><a name="tth_sEc8.4">
8.4</a>&nbsp;&nbsp;Pointers as Components</h3>

<p>
One limitation of Fortran structures is that array components must have
their length fixed in advance: an  an allocatable array cannot be a
component of a structure.  Fortunately pointer components are permitted:

<pre>
   TYPE :: document_type
      CHARACTER(80), POINTER :: line(:)
   END TYPE document_type
!
   TYPE(document_type) :: mydoc  ! declare a structured variable
   ALLOCATE(mydoc%line(1200))    ! space for 1200-lines of text

</pre>
To make the structure even more flexible one might allocate an array of
<tt>CHARACTER(LEN=1)</tt> variables to hold each line of text, although this
would not be as easy to use.

<p>
In order to pass a structured variable to a procedure it is necessary for
the same structure definition to be provided on both sides of the
interface.  The easiest way to do this is to use a module. 

<p>
There are, however, two limitations on the use of derived type variables
containing pointer components:

<ol type="1"><p>
<li> They may not be used in the I/O lists of <tt>READ</tt> or <tt>WRITE</tt>
statements.</li>
<p>
<li> If an assignment statement copies one derived type variable to
another, any pointer component merely <b>clones</b> the pointer, the new
pointer still points to the same area of storage.</li>
</ol>

<p>
     <h3><a name="tth_sEc8.5">
8.5</a>&nbsp;&nbsp;Defined and overloaded operators</h3>

<p>
When a new data type is defined, it would often be nice if objects of
that type could be used in expressions, because it is much easier to
write, say <br />
<tt>a * b + c * d</tt> 
than <br />
<tt>add(mult(a,b),mult(c,d))</tt>.

<p>
Each operator you want to use has to be defined, or <b>overloaded</b>, for each
derived data type.

<p>
This example defines a new data type, <tt>fuzzy</tt>, which contains
a real value and its standard-error.  When two <i>fuzzy</i> values
are added the errors add quadratically.  Here we define or
<b>overload</b> the  ``<tt>+</tt>'' operator:

<p>

<pre>
  MODULE fuzzy_maths
    IMPLICIT NONE
    TYPE fuzzy
      REAL :: value, error
    END TYPE fuzzy
    INTERFACE OPERATOR (+)
      MODULE PROCEDURE fuzzy_plus_fuzzy
    END INTERFACE
  CONTAINS
    FUNCTION fuzzy_plus_fuzzy(first, second) RESULT (sum)
      TYPE(fuzzy), INTENT(IN) :: first, second  ! INTENT(IN) required
      TYPE(fuzzy)             :: sum
      sum%value = first%value + second%value
      sum%error = SQRT(first%error**2 + second%error**2)
    END FUNCTION fuzzy_plus_fuzzy
  END MODULE fuzzy_maths

PROGRAM test_fuzzy
IMPLICIT NONE
USE fuzzy_maths
TYPE(fuzzy) a, b, c
  a = fuzzy(15.0, 4.0) ;  b = fuzzy(12.5, 3.0)
  c = a + b
  PRINT *, c
END PROGRAM test_fuzzy

</pre>
The result is, as you would expect: <tt>&nbsp;&nbsp;&nbsp;27.5&nbsp;&nbsp;&nbsp;&nbsp;5.0</tt>

<p>
In a similar way, the assignment operator, <tt>=</tt> can also be overloaded
for derived data types, but in this case one uses a subroutine with one
argument <tt>INTENT(IN)</tt> and the other <tt>INTENT(OUT)</tt>.

<p>
Further definitions might cover:

<ul><p>
<li> Other operators: <b>- / * **</b> etc.</li>
<p>
<li> Combinations of <i>real</i> and <i>fuzzy</i> operands.</li>
<p>
<li> Intrinsic functions like <tt>SQRT</tt>.</li>
</ul>

<p>
When a new data type has been defined in this way:

<ul><p>
<li> It can be retro-fitted to existing software with a <tt>USE</tt>
statement and a few changes from <tt>REAL</tt> to <tt>TYPE(FUZZY)</tt>.</li>
<p>
<li> It is possible to change the internal representation without
affecting the software which uses the fuzzy type if the interfaces are
preserved.</li>
</ul>

<p>
<b>Overloading</b> an existing operator is sensible only if the meaning is
unchanged.  Otherwise it is best to invent a new one.
For example, <b>.like.</b> to compare to character-strings, or
<b>.union.</b> for a set-operator.

<p>
<i>The precedence</i> of an existing operator is unchanged by
overloading; new unary operators have a higher precedence, and new
binary operators have a lower precedence than all intrinsic operators.

<p>
 <h2><a name="tth_sEc9">
9</a>&nbsp;&nbsp;Input Output</h2>

<p>
     <h3><a name="tth_sEc9.1">
9.1</a>&nbsp;&nbsp;New <tt>OPEN</tt> and <tt>INQUIRE</tt> options</h3>

<ul><p>
<li> <tt>ACTION="READ"</tt> - to ensure read-only access (other actions are <tt>
"WRITE"</tt> or <tt>"READWRITE"</tt>).</li>
<p>
<li> <tt>POSITION=&#196;PPEND"</tt> - to append to an existing sequential file.</li>
<p>
<li> <tt>POSITION="REWIND"</tt> - to ensure that existing file opened at
beginning (more portable).</li>
<p>
<li> <tt>STATUS="REPLACE"</tt> - to overwrite any old file or create a new
one.</li>
<p>
<li> <tt>RECL=length</tt> - can also be used when creating a <b>sequential</b>
file such as a text file to specify the (maximum) record length required (units are <i>
characters</i> for formatted access, otherwise system-dependent).</li>
</ul>

<p>
The <tt>INQUIRE</tt> statement has additional keywords to return information
on these aspects of an open unit.

<p>
The <b>record-length units</b> of an unformatted (binary) direct-access 
are system-dependent: there is now a portable solution using a new form 
of the <tt>
INQUIRE</tt> statement.  You supply a specimen I/O list and it returns the
length to use in the <tt>OPEN</tt> statement.

<pre>
  INQUIRE(IOLENGTH=length) specimen, list, of, items
  OPEN(UNIT=unit, FILE=fname, STATUS="new", ACCESS="direct", RECL=length)

</pre>

<p>
     <h3><a name="tth_sEc9.2">
9.2</a>&nbsp;&nbsp;Internal File I/O</h3>
List-directed (free-format) reads and writes can now be used with internal
files:

<pre>
  CHARACTER(LEN=10) :: string
  string = "   3.14   "
  READ(string, *) somereal

</pre>

<p>
     <h3><a name="tth_sEc9.3">
9.3</a>&nbsp;&nbsp;Formatted I/O</h3>
New/improved descriptors for formatted read and write:

<pre>
  REAL :: x = 0.125
  WRITE(*, "(E12.3, ES12.3, EN12.3)") x, x, x

</pre>
produces:

<pre>
   0.125E+00   1.250E-01 125.000E-03

</pre>
<tt>ESw.d</tt> produces <b>
scientific format</b> with the decimal after the first digit, while <tt>
ENw.d</tt> produces <b>engineering format</b> with an exponent which is always
a multiple of 3.   For input they are all exactly equivalent.

<p>
Integers can be read/written using hexadecimal, octal, or
binary conversions:

<pre>
  INTEGER :: n = 125
  WRITE(*, "(I10, Z10, O10, B10)") n, n, n, n

</pre>
Produces:

<pre>
       125        7D       175   1111101

</pre>
All these may specify a <b>minimum number of digits</b> to be 
output: e.g. <tt>Z10.6</tt> 

<p>
The <b>generic descriptor</b> <tt>Gw.d</tt> may be used for all data 
types, including logical and character.

<p>
     <h3><a name="tth_sEc9.4">
9.4</a>&nbsp;&nbsp;Non-advancing I/O</h3>

<p>
This is a new facility, not quite stream-I/O, but nearly.  Normal
(advancing) <tt>READ</tt> and <tt>WRITE</tt> statements always process at least
one whole record.  Non-advancing ones only move a notional pointer as far
as needed.  A non-advancing write allows user input on the same line as a
screen-prompt:

<pre>
  WRITE(*, "(A)", ADVANCE="no") "Enter the number of iterations: "
  READ(*, *) nloops

</pre>
A non-advancing read can measure the actual length of an input line using
the new <tt>SIZE</tt> keyword.

<pre>
  CHARACTER(LEN=80) :: text
  INTEGER :: nchars, code
  READ(unit, "(A)", ADVANCE="no", SIZE=nchars, IOSTAT=code) text

</pre>
If the line entered is too short then the <tt>IOSTAT</tt> return-code will be
negative (and different from the value signalling end-of-file).

<p>
 <h2><a name="tth_sEc10">
10</a>&nbsp;&nbsp;Character Handling</h2>

<p>
Much simpler, especially because of the many new or improved 
<b>intrinsic functions</b>:

<p>

<center>
<table>
<tr><td><tt>c = ACHAR(I)</tt> </td><td>Char in Ith position in ASCII table </td></tr>
<tr><td><tt>i = IACHAR(C)</tt> </td><td>Position of Char in ASCII table </td></tr>
<tr><td><tt>i = LEN_TRIM(STRING)</tt> </td><td>Length ignoring trailing spaces </td></tr>
<tr><td><tt>s = TRIM(STRING)</tt> </td><td>String with trailing spaces removed </td></tr>
<tr><td><tt>s = ADJUSTL(STRING)</tt> </td><td>Adjust left by removing leading spaces</td></tr>
<tr><td><tt>s = ADJUSTR(STRING)</tt> </td><td>Adjust right by removing trailing spaces</td></tr>
<tr><td><tt>s = REPEAT(STRING, NCOPIES)</tt> </td><td>Repeated concatenation </td></tr>
<tr><td><tt>i = INDEX(STRING, SUBSTRING, back)</tt> </td><td>reverse search if back .true.</td></tr>
<tr><td><tt>i = SCAN(STRING, SET, back)</tt> </td><td>Scan for 1st of any of set of chars </td></tr>
<tr><td><tt>i = VERIFY(STRING, SET, back)</tt> </td><td>Scan for 1st char not in set </td></tr></table>

</center>

<p>
<b>Other changes:</b>

<p>
<b>Overlapping substrings</b> in assignments are permitted:

<pre>
   text(1:5) = test(3:7)   ! now ok, invalid in Fortran77

</pre>

<p>
The <b>concatenation operator</b> <tt>//</tt> may be used without restriction 
on procedure arguments of passed-length. 

<p>
<b>Character functions</b> may return a string with a length which depends on
the function arguments, e.g. 

<pre>
   FUNCTION concat(s1, s2)
   IMPLICIT NONE
   CHARACTER(LEN=LEN_TRIM(s1)+LEN_TRIM(s2)) :: concat  ! function name
   CHARACTER(LEN=*), INTENT(IN) :: s1, s2
   concat = TRIM(s1) // TRIM(s2)
   END FUNCTION concat

</pre>

<p>
<b>Zero-length</b> strings are permitted, e.g.&nbsp;a sub-string reference like
<tt>string(k:n)</tt> where k  &gt;  n, or a constant like <tt>""</tt>.

<p>
<b>Sub-strings</b> of constants are permitted, e.g.&nbsp;to convert an
integer, <b>k</b>, in the range 0 to 9 into the corresponding character:

<pre>
   achar = "0123456789"(k:k)   ! note: error if k &lt; 0 or k &#62; 9.

</pre>

<p>
 <h2><a name="tth_sEc11">
11</a>&nbsp;&nbsp;Pointers</h2>

<p>
Many programming languages support pointers, as they make it easier to
implement dynamic data structures such as linked lists, stacks, and
trees.  Programs in C are heavily dependent on pointers because an array
passed to a function instantly turns into a pointer.  <b>But:</b>

<p>

<ul><p>
<li> Pointers may force the programmer to do low-level accounting 
better left to the the compiler.</li>
<p>
<li> Excessive use of pointers leads to obscure and
unmaintainable code.</li>
<p>
<li> It is easy to make mistakes detectable only at run-time: a 
high proportion of bugs in C arise from accidental misuse
of pointers.</li>
<p>
<li> Pointers inhibit compiler optimisation (because  two apparently
distinct objects may be just pointers to the same memory location).</li>
</ul>
The Java language is, to a large extent, a pointer-free dialect of C++.
Clearly pointers must to be used with care.  Fortunately Fortran pointers
are relatively tame.

<p>
     <h3><a name="tth_sEc11.1">
11.1</a>&nbsp;&nbsp;Pointer Rules</h3>
A pointer can only point to another pointer or to a variable
explicitly declared to be a valid <tt>TARGET</tt>.

<p>
Unfortunately a pointer starts life in
limbo, neither associated nor disassociated (fixed in Fortran95).  The
best practice is to nullify each pointer at the start of execution, like
this:

<pre>
   NULLIFY(parray)

</pre>
and then a test of <tt>ASSOCIATED(parray)</tt> would be valid, and would
return <tt>.false.</tt> until it had been pointed at some actual storage.

<p>
When a pointer array is passed as an argument to a procedure which also
declares it to be a pointer, the lower-bounds of the argument are passed
across as well as the upper-bounds.  In all other cases, the lower bounds
need to be specifically declared in the procedure, and default to one
unless otherwise specified.

<p>
     <h3><a name="tth_sEc11.2">
11.2</a>&nbsp;&nbsp;Array of arrays</h3>
Fortran does not allow an array of pointers, but it does allow an
array of derived-type objects which have pointers as components.

<pre>
   TYPE :: ptr_to_array
     REAL, DIMENSION(:), POINTER :: arr
   END TYPE ptr_to_array
   TYPE(ptr_to_array), ALLOCATABLE :: x(:)
   !...
   ALLOCATE(x(nx))
   DO i = 1,nx
      ALLOCATE(x(i)%arr(m))
   END DO

</pre>

<p>
     <h3><a name="tth_sEc11.3">
11.3</a>&nbsp;&nbsp;Pointer as alias</h3>
Pointers are valuable as short-hand notation for array sections, e.g.

<pre>
   REAL, TARGET :: image(1000,1000)
   REAL, DIMENSION(:,:), POINTER :: alpha, beta
   alpha =&#62; image(1:500, 501:1000)
   beta  =&#62; image(1:1000:2, 1000:1,-2)   ! axis flipped

</pre>
Note that pointer assignment uses the symbol <tt>=&#62;</tt> to
distinguish the operation from actual assigment of a value.

<p>
     <h3><a name="tth_sEc11.4">
11.4</a>&nbsp;&nbsp;Function may return a pointer</h3>

<p>
A case in which it is useful for a function to return a pointer to an array
is illustrated by the reallocate function below.

<p>

<pre>
MODULE realloc_mod
CONTAINS
  FUNCTION reallocate(p, n)               ! reallocate REAL
    REAL, POINTER, DIMENSION(:) :: p, reallocate
    INTEGER, intent(in) :: n
    INTEGER :: nold, ierr
    ALLOCATE(reallocate(1:n), STAT=ierr)
    IF(ierr /= 0) STOP "allocate error"
    IF(.NOT. ASSOCIATED(p)) RETURN
    nold = MIN(SIZE(p), n)
    reallocate(1:nold) = p(1:nold)
    DEALLOCATE(p) 
  END FUNCTION REALLOCATE
END MODULE realloc_mod

PROGRAM realloc_test
USE realloc_mod
IMPLICIT NONE
REAL, POINTER, DIMENSION(:) :: p
INTEGER :: j, nels = 2
  ALLOCATE(p(1:nels))
  p(1) = 12345
  p =&#62; reallocate(p, 10000)    ! note pointer assignment
  WRITE(*,*) "allocated ", nels, size(p), " elements"
  WRITE(*,*) "p(1)=", p(1)
END PROGRAM realloc_test

</pre>

<p>
Note that pointer assignment uses the symbol <tt>=&#62;</tt> since it needs to be
distinguished from simple assignment of a value.

<p>
     <h3><a name="tth_sEc11.5">
11.5</a>&nbsp;&nbsp;Dynamic Data Structures</h3> 

<p>
Pointers can be used to construct complex dynamic data structures of all
types, such as singly and doubly-linked-lists, binary-trees, etc.   
This is possible because a variable of derived type may contain a pointer
which points to itself or to another object of the same type.  

<p>
Pointers may only point to objects which have been declared with the <tt>
TARGET</tt> attribute, to other pointers, or to arrays allocated to
a pointer.  

<p>
 <h2><a name="tth_sEc12">
12</a>&nbsp;&nbsp;Portable Precision</h2>

<p>
It was a common extension to Fortran77 to allow declarations of the form
<tt>LOGICAL*1</tt>, <tt>INTEGER*2</tt>, or <tt>REAL*8</tt>.  But this simple scheme was
<b>not</b> adopted for Fortran90.  

<p>
Instead Fortran90 defines 5 distinct intrinsic
data types (character, logical, integer, real, complex) but allows for
different <b>kinds</b> of them to exist.  Two kinds of <b>real</b> and <b>
complex</b> are required (the second kind of real has the alias of <tt>DOUBLE
PRECISION</tt>.  Systems may support additional kinds of any of the 5 intrinsic
data types.

<p>
The <b>kind</b> is specified with an integer, e.g. <tt>INTEGER(2)</tt> instead
of <tt>INTEGER*2</tt> but the Standard does not define what the integer means.
To make software portable, two intrinsic functions are provided: 
<tt>SELECTED_INT_KIND</tt> selects an integer kind value for the minimum number of
decimal digits you want, and <tt>SELECTED_REAL_KIND</tt> does the same for
reals given the minimum significant decimal digits and exponent range.
Thus:

<p>

<pre>
   INTEGER, PARAMETER :: &amp;
     short = SELECTED_INT_KIND(4), &amp;   ! &#62;= 4-digit integers
     long  = SELECTED_INT_KIND(9), &amp;   ! &#62;= 9-digit integers
     dble  = SELECTED_REAL_KIND(15, 200)  ! 15-digit reals to 10**200

   INTEGER(short) :: myimage(1024,1024) 
   INTEGER(long)  :: counter
   REAL(double) :: processed_data(2000,2000)

</pre>

<p>
It may be that on some systems the same kind of integer would be used for
those declared <tt>short</tt> and <tt>long</tt>, but this should not affect
portability.

<p>
The best practice is to include definitions of kind parameters (like those
above) in a <b>module</b> which is used throughtout the program.

<p>
<b>Constants</b> may have their kind parameter appended, where kind matching
is required (e.g.&nbsp;in procedure arguments):

<pre>
   CALL somesub( 3.14159265358_dble, 12345_long, 42_short)

</pre>

<p>
Another intrinsic function, <tt>KIND</tt> returns the kind parameter of any
variable.

<pre>
   WRITE(*,*) " Double precision kind is ', KIND(0d0)

</pre>

<p>
In principle the kind system may be extended to characters - Fortran
systems are free to support 16-bit character-sets such as Unicode.

<p>
 <h2><a name="tth_sEc13">
13</a>&nbsp;&nbsp;Other features</h2> 

<p>
     <h3><a name="tth_sEc13.1">
13.1</a>&nbsp;&nbsp;Bit-wise operations on integers</h3>

<p>
All the MIL-STD intrinsics for bit-manipulation are now standardized.
Bit are numbered from 0 on the right, i.e.&nbsp;the least-significant end.

<p>

<center>
<table>
<tr><td><tt>i = BTEST(i, ipos)</tt>      </td><td>Bit testing </td></tr>
<tr><td><tt>i = IAND(i, j)</tt>          </td><td>Logical AND </td></tr>
<tr><td><tt>i = IBCLR(i, ipos)</tt>      </td><td>Clear bit </td></tr>
<tr><td><tt>i = IBITS(i, ipos, len)</tt> </td><td>Bit extraction </td></tr>
<tr><td><tt>i = IBSET(i, ipos)</tt>      </td><td>Set bit </td></tr>
<tr><td><tt>i = IEOR(i, j)</tt>          </td><td>Exclusive OR </td></tr>
<tr><td><tt>i = IOR(i, j)</tt>           </td><td>Inclusive OR </td></tr>
<tr><td><tt>i = ISHFT(i, j)</tt>         </td><td>Logical shift left (right if <tt>j</tt> -ve) </td></tr>
<tr><td><tt>i = ISHFTC(i, j)</tt>        </td><td>Circular shift left (right if <tt>j</tt> -ve) </td></tr>
<tr><td><tt>i = NOT(i)</tt>              </td><td>Logical complement </td></tr>
<tr><td></td></tr>
<tr><td><tt>i = BIT_SIZE(i)</tt>  </td><td>Number of bits in variables of type <tt>i</tt> </td></tr></table>

</center>

<p>
<tt>CALL MVBITS(from, frompos, len, to, topos)</tt> is an intrinsic
subroutine which copies bits from one integer to another.

<p>
<b>Binary, octal</b>, and <b>hex</b> values may be read and written
using new format descriptors <tt>Bw.d, Ow.d, Zw.d</tt>, and that
<tt>DATA</tt> statements may contain binary, octal, and hex constants.

<p>
     <h3><a name="tth_sEc13.2">
13.2</a>&nbsp;&nbsp;Other intrinsic functions</h3>

<p>
<tt>FLOOR</tt> and <tt>MODULO</tt> 
work like <tt>AINT</tt> and <tt>MOD</tt> but do sensible things on negative
numbers, and <tt>CEILING</tt> which rounds up to the next whole number.

<p>
<tt>TRANSFER</tt> may be used to copy the bits from one data type to
another - a type-safe
alternative to tricks formerly played with <tt>EQUIVALENCE</tt> statements.

<pre>
   LOGICAL, PARAMETER :: bigend = IACHAR(TRANSFER(1,"a")) == 0

</pre>
This sets <tt>bigend</tt> to <tt>.TRUE.</tt> on a big-endian hardware platform,
and <tt>.FALSE.</tt> otherwise.

<p>
<b>Numerical enquiry functions</b> include
<tt>BIT_SIZE</tt>, <tt>DIGITS</tt> <tt>EPSILON</tt>,
<tt>MAXEXPONENT</tt>,  <tt>MINEXPONENT</tt>, <tt>PRECISION</tt>,
<tt>RADIX</tt>, and <tt>RANGE</tt>.  Perhaps the most useful of these are
<tt>TINY</tt> which returns the smallest non-zero real (of whatever kind),
and <tt>HUGE</tt> which returns the largest representable number (integer
or real).

<p>
<b>System access</b> intrinsics include: <br />
<tt>DATE_AND_TIME</tt>, an intrinsic subroutine, which returns the current date and time as a string
or an array of integers, <br />
<tt>RANDOM_NUMBER</tt> which returns a whole array
of pseudo-random numbers, <br />
<tt>RANDOM_SEED</tt> which can randomise the
seed.  <br />
<tt>SYSTEM_CLOCK</tt> useful in timing tests.  <br />
In
Fortran95 a true <tt>CPU_TIME</tt> routine is introduced.

<p>
 <h2><a name="tth_sEc14">
14</a>&nbsp;&nbsp;Resources</h2>

<p>
Best WWW resources:

<p>
The Fortran market: <tt>http://www.fortran.com/fortran</tt>

<p>
FAQ at <tt>
http://www.ifremer.fr/ditigo/molagnon/fortran90/engfaq.html</tt>

<p>
These have links to tools such as style-converters and interface block
generators, free software, and commercial products.

<p>
The Usenet news group <tt>comp.lang.fortran</tt> now has almost as many
postings  on Fortran90 as on Fortran77.

<p>
The mailing list <tt>comp-fortran-90</tt> has on-line archives at
<tt>http://www.jiscmail.ac.uk</tt> which also contains joining instructions. 

<p>
The best <b>book</b> on Fortran90 for existing Fortran users is, in my
opinion, 
<b>Upgrading to Fortran 90</b> by Cooper Redwine, published by 
Springer, 1995, ISBN 0-387-97995-6.  

<p>
An alternative is <i>Fortran90/95 Explained</i> by Michael Metcalf &amp;
John Reid, published by Oxford University Press, ISBN 0 19 851888 9.
This is comprehensive, but in my opinion, sometimes a bit too concise.

<p>
See also <b>Numerical Recipes in Fortran90</b> by Press et.&nbsp;al.&nbsp;
published by CUP, ISBN 0-521-57439-0.

<p>
 <h2><a name="tth_sEc15">
15</a>&nbsp;&nbsp;Language Progression</h2>

<p>
     <h3><a name="tth_sEc15.1">
15.1</a>&nbsp;&nbsp;Deprecated features</h3>
The following features of antique Fortran are officially termed <b>
deprecated</b> and some of them have been officially removed from Fortran95
(but most compilers just issue warnings if you use them):

<ul><p>
<li> <tt>DO</tt> with a control variable of type <tt>REAL</tt> or <tt>DOUBLE
PRECISION</tt>.</li>
<p>
<li> A <tt>DO</tt> loop ending on a statement other than <tt>CONTINUE</tt> or
<tt>END DO</tt>.</li>
<p>
<li> Two or more <tt>DO</tt> loops ending on the same statement.</li>
<p>
<li> The <b>arithmetic</b> <tt>IF</tt> statement (three-way branch).</li>
<p>
<li> Hollerith <tt>FORMAT</tt> descriptor n<tt>H</tt><i>string</i>.</li>
<p>
<li> A branch to <tt>END IF</tt> from outside the IF-block (allowed in
Fortran77 by mistake).</li>
<p>
<li> The <tt>PAUSE</tt> statement.</li>
<p>
<li> The <tt>ASSIGN</tt> statement together with <b>assigned</b> <tt>GO TO</tt> 
and <b>assigned</b> <tt>FORMAT</tt> statements.</li>
<p>
<li> The alternate <tt>RETURN</tt> facility.</li>
</ul>
If you are unfamiliar with these, then you never need to know about them.

<p>
     <h3><a name="tth_sEc15.2">
15.2</a>&nbsp;&nbsp;Superseded features</h3>
Some other features, still commonly used in Fortran77, are essentially
redundant and should be avoided in newly-written code.  For example:
Fixed source form, implicit data typing, COMMON blocks, assumed-size
arrays, <b>EQUIVALENCE</b>, <b>ENTRY</b>,  <b>INCLUDE</b>,
<b>BLOCK DATA</b> program units. Specific names of intrinsics.

<p>
     <h3><a name="tth_sEc15.3">
15.3</a>&nbsp;&nbsp;Main New Features of Fortran95</h3>

<p>
The major features include 

<ul><p>
<li> <tt>FORALL</tt> statement and construct, e.g. <br />
<tt>FORALL(i=1:20, j=1,20) x(i,j) = 3*i + j**2</tt></li>
<p>
<li> <tt>PURE</tt> and <tt>ELEMENTAL</tt> user-defined subprograms</li>
<p>
<li> initial association status for pointers using <tt>=&#62; NULL()</tt></li>
<p>
<li> implicit initialisation of derived type objects</li>
<p>
<li> new intrinsic function <b>CPU_TIME</b></li>
<p>
<li> automatic deallocation of allocatable arrays</li>
<p>
<li> Format width zero (e.g. <tt>i0</tt>) produces minimum number of
digits required.</li>
</ul>

<p>
A good on-line coverage of these new features is given in
http://www.nsc.liu.se/&nbsp;boein/f77to90/f95.html

<p>
     <h3><a name="tth_sEc15.4">
15.4</a>&nbsp;&nbsp;Possible New Features of Fortran2000</h3>

<p>

<ul><p>
<li> High Performance, Scientific and Engineering Computing: 
  
<ul><p>
<li>           Asynchronous I/O</li>
<p>
<li>           Floating point exception handling</li>
<p>
<li>           Interval arithmetic</li>
</ul></li>
<p>
<li>      Data Abstraction / User Extensibility: 
   
<ul><p>
<li>           Allocatable components</li>
<p>
<li>           Derived type I/O</li>
</ul></li>
<p>
<li>      Object-oriented Fortran: 
   
<ul><p>
<li>           Constructors/destructors</li>
<p>
<li>           Inheritance</li>
<p>
<li>           Polymorphism</li>
</ul></li>
<p>
<li>      Parameterised derived types</li>
<p>
<li>      Procedure pointers</li>
<p>
<li>           Internationalization</li>
<p>
<li>           Inter-operability with C</li>
</ul>

<p>
The name is not yet decided, may be Fortran 2002!

<p>

<br /><br /><hr /><small>File translated from
T<sub><font size="-1">E</font></sub>X
by <a href="http://hutchinson.belmont.ma.us/tth/">
T<sub><font size="-1">T</font></sub>H</a>,
version 3.02.<br />On 26 Nov 2001, 16:49.</small>
</html>
