<html>
<head>
<title>Hash Functions for Hash Table Lookup</title>
<meta name="keywords" content="hash, hash function, funneling,
hash table lookup, random mapping">
</head>
<body bgcolor="#ffffff" text="#000000" link="#0000ff"
vlink="#00ff00" alink="#ff0000">
<center><h1>Hash Functions for Hash Table Lookup</h1></center>
<center>Robert J. Jenkins Jr., 1995-1997</center>

<hr size=1>

<a name="abstract"><center><h4>Abstract</h4></center></a>

<p>This paper presents new hash functions for table lookup using
32-bit or 64-bit arithmetic.  These hashes are fast and reliable.
A framework is also given for evaluating hash functions.

<a name="introduction"><h3>Introduction</h3></a>

<p><b>Hash tables</b> <a href="#Knuth6"><sup>[Knuth6]</sup></a> are a
common data structure.  They consist of an array (the <b>hash
table</b>) and a mapping (the <b>hash function</b>).  The hash
function maps <b>keys</b> into <b>hash values</b>.  Items stored in
a hash table must have keys.  The hash function maps the key of an item
to a hash value, and that hash value is used as an index into the hash
table for that item.  This allows items to be inserted and located
quickly.

<p>What if an item hashes to a value that some other item has already
hashed to?  This is a <b>collision</b>.
There are several strategies for dealing with collisions <a
href="#Knuth6"><sup>[Knuth6]</sup></a>, but the strategies all make
the hash tables slower than if no collisions occurred.

<p>If the actual keys to be used are known before the hash function is
chosen, it is possible to choose a hash function that causes no
collisions.  This is known as a <b><a href="perfect.html">perfect
hash function</a></b> <a href="#Fox"><sup>[Fox]</sup></a>.  This paper
will deal with the other case, where the actual keys are a small
subset of all possible keys.

<p>For example, if a hash function maps 30-byte keys into a 32-bit
output, it maps 2<sup>240</sup> possible keys into 2<sup>32</sup>
possible hash values.  Less than 2<sup>32</sup> actual keys will be
used.  With a ratio of 2<sup>208</sup> possible keys per hash value,
it is impossible to guarantee that the actual keys will have no
collisions.

<p>If the actual keys being hashed were uniformly distributed,
selecting the first <i>v</i> bits of the input to be the <i>v</i>-bit
hash value would make a wonderful hash function.  It is fast and it
hashes an equal number of possible keys to each hash value.
Unfortunately, the actual keys supplied by humans and computers are
seldom uniformly distributed.  Hash functions must be more clever than
that.

<p>This paper is organized as follows.  <a href="#lookup">Hash
Functions for Table Lookup</a> present the new 32-bit and 64-bit
hashes.  <a href="#patterns">Patterns</a> lists some patterns common
in human-selected and computer-generated keys.  A <a
href="#standard">Hash Model</a> names common pieces of hash
functions.  <a href="#funneling">Funneling</a>
describes a flaw in hash functions and how to detect that flaw.  <a
href="#characteristic">Characteristics</a> are a more subtle flaw.
The last section shows that <a href="#haveno">the new hashes have no
funnels</a>.

<a name="lookup"><h3>Hash Functions for Table Lookup</h3></a>

<p><a href="../c/lookup2.c">Code</a> for the new hash function is given in
figure <a href="#newhash">Newhash</a>.  <tt>^</tt> means exclusive-or,
and <tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt> are left and right shift
respectively (neither is a barrelshift).

<a name="newhash"><p><center><i>Newhash: C code for the new 32-bit
hash</i></center></a>
<pre>

typedef  unsigned long int  u4;   /* unsigned 4-byte type */
typedef  unsigned     char  u1;   /* unsigned 1-byte type */

/* The mixing step */
#define mix(a,b,c) \
{ \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;13); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;8);  \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;13); \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;12); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;16); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;5);  \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;3);  \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;10); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;15); \
}

/* The whole new hash function */
u4 hash( k, length, initval)
register u1 *k;        /* the key */
u4           length;   /* the length of the key in bytes */
u4           initval;  /* the previous hash, or an arbitrary value */
{
   register u4 a,b,c;  /* the internal state */
   u4          len;    /* how many key bytes still need mixing */

   /* Set up the internal state */
   len = length;
   a = b = 0x9e3779b9;  /* the golden ratio; an arbitrary value */
   c = initval;         /* variable initialization of internal state */

   /*---------------------------------------- handle most of the key */
   while (len &gt;= 12)
   {
      a=a+(k[0]+((u4)k[1]&lt;&lt;8)+((u4)k[2]&lt;&lt;16) +((u4)k[3]&lt;&lt;24));
      b=b+(k[4]+((u4)k[5]&lt;&lt;8)+((u4)k[6]&lt;&lt;16) +((u4)k[7]&lt;&lt;24));
      c=c+(k[8]+((u4)k[9]&lt;&lt;8)+((u4)k[10]&lt;&lt;16)+((u4)k[11]&lt;&lt;24));
      mix(a,b,c);
      k = k+12; len = len-12;
   }

   /*------------------------------------- handle the last 11 bytes */
   c = c+length;
   switch(len)              /* all the case statements fall through */
   {
   case 11: c=c+((u4)k[10]&lt;&lt;24);
   case 10: c=c+((u4)k[9]&lt;&lt;16);
   case 9 : c=c+((u4)k[8]&lt;&lt;8);
      /* the first byte of c is reserved for the length */
   case 8 : b=b+((u4)k[7]&lt;&lt;24);
   case 7 : b=b+((u4)k[6]&lt;&lt;16);
   case 6 : b=b+((u4)k[5]&lt;&lt;8);
   case 5 : b=b+k[4];
   case 4 : a=a+((u4)k[3]&lt;&lt;24);
   case 3 : a=a+((u4)k[2]&lt;&lt;16);
   case 2 : a=a+((u4)k[1]&lt;&lt;8);
   case 1 : a=a+k[0];
     /* case 0: nothing left to add */
   }
   mix(a,b,c);
   /*-------------------------------------------- report the result */
   return c;
}

</pre>

<a name="register"><h4>Fitting bytes into registers</h4></a>

<p>The new hash deals with blocks of 12 bytes, rather than 1
byte at a time like <a href="examhash.html">most hashes</a>.  The mix
uses 36 instructions, which is 3 instructions per byte.  Mix() allows
2::1 parallelism, so ideally it would run twice as fast on superscalar 
CPUs.

<p>The new hash fits the bytes into the registers <tt>a</tt>,
<tt>b</tt>, and <tt>c</tt> as efficiently as
possible in a machine-independent way.  Fitting bytes into
registers consumes 3<i>m</i> instructions.  (If the key were known to
be an array of words, this 3<i>m</i> could be reduced to .75<i>m</i>.)
The whole hash, including the mix, takes about 6<i>m</i>+35
instructions to hash <i>m</i> bytes.

<p>The <tt>switch</tt> statement is an interesting
optimization.  It contains a single piece of code for handling 11-byte
strings, but the suffixes of this code can handle shorter strings.
The switch statement causes the program control to jump to the correct
suffix, determined by the actual number of bytes remaining.

<h4>A hash for 64-bit machines</h4>

<p>64-bit machines can hash faster and better with 64-bit arithmetic.
<a href="../c/lookup8.c">Code</a> for the mixing step for a hash for 64-bit
machines is given in figure <a href="#hash64">Hash64</a>.  The
modifications needed to hash() are straightforward.  It should put
24-byte blocks into 3 8-byte registers and return an 8-byte result.
The 64-bit golden ratio is <tt>0x9e3779b97f4a7c13LL</tt>.

<p><a name="hash64"><center><i>Hash64: C code for a mixing step for
64-bit machines</i></center></a>
<pre>
#define mix64(a,b,c) \
{ \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;43); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;9); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;8); \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;38); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;23); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;5); \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;35); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;49); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;11); \
  a=a-b;  a=a-c;  a=a^(c&gt;&gt;12); \
  b=b-c;  b=b-a;  b=b^(a&lt;&lt;18); \
  c=c-a;  c=c-b;  c=c^(b&gt;&gt;22); \
}
</pre>

<p>The whole 64-bit hash takes about 5<i>m</i>+41 instructions to hash
<i>m</i> bytes.

<h4>How these functions are used</h4>

<p>These hashes work equally well on all
types of input, including text, numbers, compressed data, counting
sequences, and sparse bit arrays.  No final mod, multiply, or divide
is needed to further mix the result.  If the hash value needs to be
smaller than 32 (64) bits, this can be done by masking out the high
bits, for example <tt>(hash&0x0000000f)</tt>.  The hash functions work
best if the size of the hash table is a power of 2.  If the hash table
has more than 2<sup>32</sup> (2<sup>64</sup>) entries, this can be
handled by calling the hash function twice with different initial
<tt>initval</tt>s then concatenating the results.  If the key consists
of multiple strings, the strings can be hashed sequentially, passing
in the hash value from the previous string as the initval for the
next.  Hashing a key with different initial <tt>initval</tt>s produces
independent hash values.

<p>The rest of this paper explains the design criteria for these hash
functions.

<a name="patterns"><h3>Patterns</h3></a>

<p><center><i><a name="emp">Table EMP: Is this data uniformly
distributed?</a></i></center>
<center><table>
<tr><th>EMPNO<th>ENAME<th>JOB<th>MGR<th>HIREDATE<th>SAL<th>COMM<th>DEPTNO
<tr><td>7369<td>SMITH <td>CLERK    <td>7902<td>17-DEC-80<td>800 <td>    <td>20
<tr><td>7499<td>ALLEN <td>SALESMAN <td>7698<td>20-FEB-81<td>1600<td>300 <td>30
<tr><td>7521<td>WARD  <td>SALESMAN <td>7698<td>22-FEB-81<td>1250<td>500 <td>30
<tr><td>7566<td>JONES <td>MANAGER  <td>7839<td>02-APR-81<td>2975<td>    <td>20
<tr><td>7654<td>MARTIN<td>SALESMAN <td>7898<td>28-SEP-81<td>1250<td>1400<td>30
<tr><td>7698<td>BLAKE <td>MANAGER  <td>7539<td>01-MAY-81<td>2850<td>    <td>30
<tr><td>7782<td>CLARK <td>MANAGER  <td>7566<td>09-JUN-81<td>2450<td>    <td>10
<tr><td>7788<td>SCOTT <td>ANALYST  <td>7698<td>19-APR-87<td>3000<td>    <td>20
<tr><td>7839<td>KING  <td>PRESIDENT<td>    <td>17-NOV-81<td>5000<td>    <td>10
<tr><td>7844<td>TURNER<td>SALESMAN <td>7698<td>08-SEP-81<td>1500<td>    <td>30
<tr><td>7876<td>ADAMS <td>CLERK    <td>7788<td>23-MAY-87<td>1100<td>0   <td>20
<tr><td>7900<td>JAMES <td>CLERK    <td>7698<td>03-DEC-81<td> 950<td>    <td>30
<tr><td>7902<td>FORD  <td>ANALYST  <td>7566<td>03-DEC-81<td>3000<td>    <td>20
<tr><td>7934<td>MILLER<td>CLERK    <td>7782<td>23-JAN-82<td>1300<td>    <td>10
</table></center>

Table <a href="#emp">EMP</a> is the standard toy database table, and a
typical set of data <a href="#Oracle"><sup>[Oracle]</sup></a>.

<p>A few patterns stand out.
<OL>
<LI> ENAME and JOB are the 26 uppercase ASCII letters
arranged in different orders.  The numbers in EMPNO can also appear in
MGR.  Values consist of common substrings arranged in different orders.
<LI> All the characters are ASCII, with the high bit of every byte set
to 0.  The EMPNO field is all numbers, while the ENAME field is all
uppercase letters and spaces.  Some rows even have identical values in
some columns.  Values often differ in only a few bits.
<LI> The only difference between zero and the null value
may be that the lengths are different.  Also, consider the two keys
"a" "aaa" "a" and "aa" "a" "aa".  Lengths must be considered part
of the data, otherwise such keys are indistinguishable.
<LI> Another common pattern (not present in this example) is for keys
to be nearly all zero, with only a few bits set.
</OL>

<p>Human-selected and computer-generated sets of keys almost always
match at least one of these patterns.  Most mappings of keys to hash
values map these sets of keys quite uniformly.  Unfortunately, the
hash functions that are fastest and easiest to write tend to be among
the rare functions that do poorly on these sets of keys.


<a name="standard"><h3>Hash Model</h3></a>

<p>To aid in analysis, this paper will assume that hash functions are
constructed using a <b>hash model</b>.
Although <a href="examhash.html">most hashes</a> fit this model,
some (for example MD4 <sup><a href="#MD4">[MD4]</a></sup> and Rogaway's
bucket hash <sup><a href="#Rogaway">[Rogaway]</a></sup>) do not.
Hash functions have some internal state, and a <a
href="birthday.html">permutation</a> <b>mix</b> is used to mix this
internal state.  Another function, <b>combine</b>, is used to combine
input blocks with the current internal state.

<p><a name="model"><center><i>Model for hash
functions</i></center></a>
<pre>

  initialize the internal state;
  for (each block of the input)
  {
    combine (the internal state, the current input block);
    mix( the internal state);
  }
  value = postprocess( the internal state );
  return (value);

</pre>

<p>Consider the hash function XORhash:
<pre>
  char XORhash( char *key, int len)
  {
    char hash;
    int  i;
    for (hash=0, i=0; i&lt;len; ++i) hash=hash^key[i];
    return (hash%101);           /* 101 is prime */
  }
</pre>
(XORhash requires 5<i>m</i>+3 instructions to hash <i>m</i>
bytes.  Compare that to 6<i>m</i>+35 and 5<i>m</i>+41 for the two new
hash functions.)  The internal state of XORhash is the 1-byte value
<tt>hash</tt>.  Each <tt>key[i]</tt> is an input block.  The combining
step is <tt>^</tt>.  There is no mixing step (or, the mixing step is
the identity function).  The postprocessing step is (hash%101).

<p>XORhash hashes the keys "ac" and "bd" to the same value.  The only
difference between the two keys is the first bit of each byte.  What
is the problem here?


<a name="funneling"><h3>Funneling</h3></a>

<p><img src="../picture/combine.gif" align=right width=216 height=216>
A hash function is bad if it causes collisions when keys differ in
only a few bits.  This always happens when a number of input bits can
change only a smaller number of bits in the internal state.  Funneling
formalizes this concept.

<p>Let K (keys) be the set of all <i>k</i>-bit values and <i>V</i>
(hash values) be the set of all <i>v</i>-bit values.  Let a hash
function <i>h : K -&gt; V</i> be given.  Bit <i>i</i> in 1..<i>k</i>
<b>affects</b> bit <i>j</i> in 1..<i>v</i> if two keys differing only
at input bit <i>i</i> will differ at output bit <i>j</i> about half
the time.

<p>Define <i>h</i> to be a <b>funneling hash</b> if there is some
subset <i>t</i> of the input bits which can only affect bits <i>u</i>
in the internal state, and |<i>t</i>| &gt; |<i>u</i>| and 
<i>v</i> &gt; |<i>u</i>|.
<i>h</i> has a <b>funnel</b> of those <i>t</i> input bits into those
<i>u</i> bits of the internal state.  If a hash has a funnel of
<i>t</i> bits into <i>u</i>, then <i>u</i> of those <i>t</i> bits can
cancel out the effects of the other |<i>t</i>|-|<i>u</i>|.  The set of keys
differing only in the input bits of the funnel can produce no more
than half that number of hash values.  (Those 2<sup>|<i>t</i>|</sup>
keys can produce no more than 2<sup>|<i>u</i>|</sup> out of
2<sup>v</sup> hash values.)  Differing in only a few bits is a common
pattern in human and computer keys, so a funneling hash is seriously
flawed.

<p>For example, consider XORhash and 30-byte keys.  
All 30 lowest-order key bits funnel into only the lowest-order bit of
the internal state.  Every set of a billion (2<sup>30</sup>) keys which
differ only in the lowest order key bits maps into just 2 hash values,
even though 101 hash values are available.

<p><dl>
<dt><a name="nofunnel">Theorem Nofunnel:</a>
<dd>
Unless the mixing step compresses already-mixed data, a hash matching
the hash model has no funnels if these conditions all hold:
<OL>
<LI> The postprocessing step just selects <i>v</i> bits of the
internal state to be the <i>v</i>-bit result,
<LI> When the input block is fixed, the combining step is a reversible
mapping of the internal state to the internal state,
<LI> When the original internal state is fixed, the combining step is
a one-to-one mapping (every input block value is mapped to a distinct
internal state value),
<LI> The mixing function is reversible,
<LI> The mixing step causes every bit of the internal state to affect
every bit of the result, and
<LI> The mixing step, when run either forwards or in reverse, causes
every bit of the internal state to affect at least <i>v</i> bits of
the internal state.
<LI> For every intermediate point in the mixing step, consider running
the mixing step forward to that point from the previous combine, and
backward to that point from the next combine.  For every set Y of bits
in the internal state in the middle, there some set X of bits in the
previous input block and Z in the next input block that affect those Y
bits.  For every Y with less than <i>v</i> bits, |X|+|Z| must be
less than or equal to |Y|.  (Note that if every bit in the previous
and next block affects at least <i>v</i> bits in the center of the
mixing step, this requirement is satisfied.)
</OL>
Almost all nonlinear mixing steps do not compress already-mixed data.
</dl>

The proof can be found at <a href="funnels.html">
http://burtleburtle.net/bob/hash/funnels.html</a>.

<p>There is an efficient way of testing which input bits affect which
output bits.  For an (input bit, output bit) pair, the test is to
find a key pair differing in only that input bit that changes that
output bit, and another such key pair that does not change that output
bit.  That is really two tests, one to test that the output bit
changes sometimes, and the other to test that the output bit sometimes
stays the same.

<p>How many key pairs need to be hashed?  If the input bit changes the
output bit with probability 1/2, the chances of the output not
changing at all is 1/2 for 1 pair, 1/4 for 2 pairs, 1/8 for 3 pairs,
and 2<sup><i>-x</i></sup> for <i>x</i> pairs.  If <i>n</i> tests are
being checked, and each test passes with probability 1/2, after
log(<i>n</i>) pairs there is a still a (1 - 1/<i>n</i>)<sup>n</sup> =
1/<i>e</i> chance of some test not passing.  However, if after
2log(<i>n</i>) key pairs a test has still not passed, it is safe to
say that the hash fails that test.  Key pairs differing in a given input
bit can be used to check all output bits simultaneously.  All
together, it is possible to show that every input bit affects every
output bit by hashing about <i>k</i>log(2<i>kv</i>) key pairs, and it
is possible to show that a particular (input bit, output bit) pair
fails by hashing about 2log(2<i>kv</i>) key pairs.


<a name="characteristic"><h3>Characteristics</h3></a>

<p>Characteristics are another flaw that cause hash functions to
behave poorly when keys differ in only a few bits.

<p>A <b>delta</b> is the difference (usually by XOR or subtraction)
between two values.  An <b>input delta</b> is the delta of two input
keys, and an <b>output delta</b> is the delta of two hash values.  A
<b>characteristic</b> <a href="#Biham"><sup>[Biham]</sup></a> is an
input delta that produces a predictable output delta.

<p>Suppose that a mixing function has a characteristic that occurs
with probability 1, and it has an input delta with only <i>t</i> bits
set and an output delta with only <i>u</i> bits set.  If two keys
differ in all <i>t</i> bits in block <i>k</i><sub>1</sub> and all
<i>u</i> bits in block <i>k</i><sub>2</sub>, they will produce the
same internal state.  That means any set of
2<sup><i>t</i>+<i>u</i></sup> keys differing in only those bits will
produce at most 2<sup><i>t</i>+<i>u</i>-1</sup> distinct internal
states.  This is not a funnel because each of those bits alone might
affect all output bits.  But it has the same effect as a funnel of
<i>t</i>+<i>u</i> bits into <i>t</i>+<i>u</i>-1.

<p>Unlike funneling, there are <a href="../crypto/findingc.html">no efficient
tests</a> known for checking for all characteristics.  The test for
funneling is actually a test for all <i>k</i> 1-bit deltas.  There are
(<i>k</i> choose <i>x</i>) <i>x</i>-bit deltas, and it quickly becomes
impractical to test all of them.

<p>Consider two keys, each of which is all zero except for one bit.
They can be viewed as the same key with two substrings swapped, where
the set bit was in one of the substrings.  The boundaries of the
substrings could be just about anything.  By checking the behavior of
all such pairs of keys, we can check if any two substrings are treated
commutatively.  This test is actually equivalent to checking for all
characteristics with 2-bit input deltas.


<a name="haveno"><h3>The New Hashes Have No Funnels</h3></a>

<p>The funneling test was used to choose the structure and constants
for the mixing function of the 32 bit (64 bit) hash.  By theorem <a
href="#nofunnel">Nofunnel</a>, the new hashes have no
funnels:
<OL>
<LI> The postprocessing step just selects the 32 (64) bits of
<tt>c</tt> to be the result.
<LI> The combining step (addition of the internal state and an input
block) is reversible when the input block is fixed.
<LI> The combining step is reversible (which implies one-to-one) when
the internal state is fixed.
<LI> Mix() is reversible.
<LI> Mix() causes every bit of <tt>a</tt>, <tt>b</tt>, and <tt>c</tt>
to affect every bit of the result (<tt>c</tt>) with probability
1/2+-1/6.
<LI> Mix(), when run either forwards or in reverse, causes
every bit of of <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> to affect at
least 32 (80) bits of <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> at least
1/4 (1/2) of the time.
<LI> This last point, actually, didn't hold for lookup2.c.  There is a 
funnel of 32 bits to 31 bits, with those 32 bits distributed across
two blocks.  I backed up my computer, wrote a program that found this,
then changed computers.  So I don't have the code and don't remember
where the funnel was.  A funnel of 32 bits to 31 is awfully
nonserious, though, so I let things be.
</OL>
The nonlinear permutation mix() was also run forwards and backwards
for many iterations.  Two or more iterations always caused every bit
of the internal state to affect every other bit of the internal state,
so it appears that mix() does not unmix already-mixed data.

<p>Before the final mixing step, the length is added to <tt>c</tt>.
Nothing else is added to the bottom byte of <tt>c</tt>.  The upper
length bytes may overlap the final key block, but the upper length
bytes cannot be changed without changing at least 256 bytes of the
key, so this does not introduce a funnel.

<p>Every 2-bit characteristic changes every bit as well.  The
least-affected output bit changes with probability 1/2+-28/100
(1/2+-1/6 for the 64-bit hash) for one 2-bit delta.  The 3-bit deltas
consisting of the high bits of <tt>a</tt>, <tt>b</tt>, <tt>c</tt> and
the low bits of <tt>a</tt>, <tt>b</tt>, <tt>c</tt> were also tested;
they changed every output bit with probability 1/2+-1/6.  Tests were
run both with random and with almost-all-zero keys.

<p>The tests for funneling and simple characteristics show that the
new hashes perform well when keys differ in only a few bits.  They
perform well on almost-all-zero keys.  The tests for 2-bit
characteristics also show that they do not treat any substrings
commutatively.  That covers all the common patterns, so these hashes
should work well on all classes of keys.

<a name="summary"><h3>Summary</h3></a>

<p>If a hash function funnels a number of input bits into fewer bits
in its internal state, fewer than the number of output bits, then
keys differing in only those input bits will produce at most half of
all possible hash values.  Human-selected and computer-generated sets
of keys often have keys differing in only a few bits, so hashes with
funnels should be avoided.  There is an efficient test for funnels.

<p>Two new hash functions are given for hash table lookup.
They produce full 32-bit or 64-bit results and allow hash table sizes
to be a power of two.  The new hashes are fast and reliable.  They have
no funnels, so they should work equally well on all types of keys.

<p>Further code and analysis can be found on the web at
<a href =
"http://burtleburtle.net/bob/hash/index.html">
 http://burtleburtle.net/bob/hash/index.html</a>.

<hr line=1>

<dl>
<dt><a name="Biham">Biham</a>
<dd>Biham, E. and Shamir, A.  Differential Cryptanalysis of Snefru,
Khafre, REDOC-II, LOKI, and Lucifer (extended abstract).  In
<i>Advances in Cryptography -- CRYPTO '91 Proceedings</i>, pp 156-171
<dt><a name="Fox">Fox</a>
<dd>Fox, E., Heath, L., Chen, Q., and Daoud, A.  Practical Minimal
Perfect Hash Functions for Large Databases.  <i>Communications of the
ACM</i> 35,1 (January 1992) 105-121
<dt><a name="Knuth6">Knuth6</a>
<dd>Knuth, D.  <i>The Art of Computer Programming</i>, Volume 3:
Sorting and Searching, Chapter 6.4.  Addison Wesley, 1973
<dt><a name="Schneier">Schneier</a>
<dd>Schneier, B.  <i>Applied Cryptography</i>.  John Wiley & Sons, 1993
<dt><a name="MD4">MD4</a>
<dd><a href="http://theory.lcs.mit.edu/~rivest">Rivest, R.</a>  The
MD4 Message Digest Algorithm.  In <i>Advances in Cryptology -- CRYPTO
'90 Proceedings</i>.  (1991) 303-311
<dt><a name="Oracle"><a href="http://www.oracle.com">Oracle</a></a>
<dd>Linden, B.  <i>SQL Language Reference Manual, Version 7.0</i>
Oracle Corporation, 1992.  1-15
<dt><a name="Rogaway"><a href=
"http://wwwcsif.cs.ucdavis.edu/~rogaway/papers/list.html">
Rogaway</a></a>
<dd>Rogaway, P.  Bucket Hashing and its Application to Fast Message
Authentication.  <i>Proceedings of CRYPTO '95</i> (1995)
</dl>

<hr line=1>

<p><a href="index.html">Hash functions and block ciphers</a>
<br><a href="../rand/index.html">Pseudorandom number generation</a>
<br><a href="birthday.html">The birthday paradox</a>
<br><a href="examhash.html">Examples of existing hash functions</a>
<br><a href="../index.html">Table of Contents</a>

</body>
</html>
