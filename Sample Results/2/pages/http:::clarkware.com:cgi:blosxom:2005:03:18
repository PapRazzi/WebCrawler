<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Mike Clark &#8250; Ruby Learning Test #1: Are You There, World?</title>
  <link rel="shortcut icon" type="image/ico" href="/images/favicon.ico" />
  <link rel="apple-touch-icon" href="/apple-touch-icon.png"/>
  <link href="/stylesheets/all.css?1360870353" media="screen" rel="stylesheet" type="text/css" />
  <script src="/javascripts/all.js?1360870353" type="text/javascript"></script>  
  
  <link rel="alternate" type="application/atom+xml" href="http://feeds2.feedburner.com/clarkware" />
  
</head>
<body>

<div id="wrapper">
  
<div id="header">
  <div id="nav">
    <h1 id="logotype"><a href="/"><span id="first">Mike</span> <span id="last">Clark</span></a></h1>
    <ul>
      <li class="active"><a href="/blog">Blog</a></li>
      <li><a href="/photos">Photos</a></li>
      <li><a href="/about">About</a></li>
    </ul>
  </div>
  <div id="socials">
    <ul>
      <li>
        <a href="http://feeds2.feedburner.com/clarkware">
          <img alt="RSS" src="/images/rss.png?1360870353" /></a>
      </li>
      <li>
        <a href="http://twitter.com/clarkware">
          <img alt="Twitter" src="/images/twitter.png?1360870353" /></a>
      </li>
      <li>
        <a href="http://www.flickr.com/photos/clarkware/">
          <img alt="Flickr" src="/images/flickr.png?1360870353" /></a>
      </li>
      <li>
        <a href="http://500px.com/clarkware/">
          <img alt="500px" src="/images/500px.png?1360870353" /></a>
      </li>
    </ul>
  </div>
</div>

<div id="main">
  
<div id="content" class="one-column">

<div id="blog">
  <div class="post">
	<h2 class="title">
	    <a href="/blog/2005/3/18/ruby-learning-test-1-are-you-there-world">Ruby Learning Test #1: Are You There, World?</a>
	</h2>
	<div class="date">
	  March 18, 2005
	</div>
	<div class="content">
		<p>
<i>
I truly have no idea where this is going or if it will scale.  But
I've been meaning to try it, and I'll let you judge whether it's worth
it.  Here's what I do know: It doesn't cost you anything to come along
for the ride.
</i>
</p>




<h3>How I Learned Ruby</h3>




<p>

A couple years back I flipped open the first edition of Dave and
Andy's wonderful book <a
href="http://pragmaticprogrammer.com/titles/ruby/">Programming
Ruby</a>.  A few pages in I'm introduced to my first Ruby code.  It
looks somewhat foreign... maybe it's just my strained eyes.  Ah, it's
so clean and elegant!  I want to try it.  Oh, but will I have the time
and opportunity to keep learning Ruby?  Just when I'm at the tipping
point, Dave beckons me closer: &quot;Go ahead, run the code and you'll
see the following output.&quot; Those words are intoxicating to a
programmer, and so I proceeded to write my first Ruby program.

</p>




<p> 

But it was at that very moment when I asked Ruby a question and it
responded with the answer that I learned more than Ruby.  I knew right
then that I didn't want to run the example just once.  No, I wanted to
preserve the example and ultimately build a Ruby knowledge base that I
could draw from later.  That meant the examples had to be executable
and check their own results.  That sounded familiar.  I needed to
write tests.

</p>




<p>

There was just one problem: I didn't yet know enough about Ruby to
write a test.  Oh, I could print stuff to the screen, but that sort of
manual inspection breaks down quickly.  Using JUnit had taught me the
value of writing automated tests that put the computer in charge of
remembering what outcome is expected.  Thankfully, when you install
Ruby you automatically get the <a
href="http://www.ruby-doc.org/stdlib/libdoc/test/unit/rdoc/index.html">Test::Unit</a>
unit testing module.  And so I had to learn enough about Test::Unit to
learn Ruby itself.  The result, years later, is the following:

</p>




<blockquote>
<pre>
[~/work/code/ruby/learn] $ ruby all_learning_tests.rb 
ruby all_learning_tests.rb
Loaded suite all_learning_tests
Started
.......................... (a lot more dots)
Finished in 1.467719 seconds.

215 tests, 452 assertions, 0 failures, 0 errors
</pre>
</blockquote>




<p> 

That's pretty much everything I know about Ruby, give or take.  It's a
living repository of knowledge; the test suite grows each time I learn
something new.  Promptly after installing a new version of Ruby, I run
the test suite.  I do that not necessarily because I think the tests
will find a bug, but rather to get a heads-up when something has
changed and I need to reset my expectations.  It's also a good way to
identify when something has been deprecated.

</p>




<p>

But the real value of writing these tests was less about testing, and
more about learning.  Through trial and error they taught me how Ruby
and its rich set of libraries really work.  Not surprisingly, typing
in code and running it makes you remember.  Indeed, writing learning
tests is a fun way to poke and prod <i>any</i> new language or API.
And with every test you write you're investing in an executable
knowledge base.

</p>




<h3>So You Want To Learn Ruby?</h3>




<p>

Perhaps you've been meaning to learn Ruby for fun or profit, but you
just don't know where to start.  I'd like to help by trying a bit of
an experiment.  No, I'm not going to send you a copy of my Ruby
learning tests.  The learning comes through doing.  

</p>




<p> 

Rather, I'll start by showing you how I wrote my first Ruby
learning test.  Then, over the coming weeks and months, I'll spoonfeed
you more tests as a starting point for exploring new facets of Ruby.
(<a href="mailto:mike@clarkware.com?subject=Ruby Tests">Submissions</a> are appreciated, too.)  Of course, if I get
the sense that nobody's listening, I'll stop.  

</p>




<p>

After we get the fundamentals down, I won't try to explain in depth
what the Ruby code in each test does.  If the test is written well,
you won't need an explanation.  And frankly, you really do need a copy
of <a href="http://pragmaticprogrammer.com/titles/ruby/">Programming
Ruby</a> for a definitive guide and tutorial to Ruby.  (Disclaimer: I
don't get royalties from sales of the book, but it's quite excellent
and it saves me typing here.)  When I introduce a major new topic,
I'll try to call out page numbers from that book.  Then you can go to
those pages, read up on how and why something works, and codify your
understanding with learning tests.

</p>




<p>

One caution before we go any further: Ruby has spoiled many
programmers.

</p>




<h3>Write a Learning Test</h3>


<p></p>

<p>

Starting is always the difficult part, so let's get right to it.
Download and install Ruby using the <a
href="http://rubyinstaller.rubyforge.org/wiki/wiki.pl">one-click
Windows installer</a>, <a
href="ftp://ftp.ruby-lang.org/pub/ruby/ruby-1.8.2.tar.gz">tarball</a>,
or any other <a
href="http://ruby-lang.org/en/20020102.html">option</a>.

</p>




<p> 

Now we get to write our first learning test.  Strings are always fun
and easy pickings, plus they usually have a lot of interesting methods
to play with.  So change to a directory where your learning tests will
live (mine's called <tt>learn</tt>) and create a file called
<tt>string_test.rb</tt> that contains the following Ruby code: </p>




<blockquote>
<pre>
require 'test/unit'

class StringTest < Test::Unit::TestCase

  def test_length
    s = "Hello, World!"
    assert_equal(13, s.length)
  end

end
</pre>
</blockquote>




<p> 

You just wrote your first Ruby class!  The <tt>require</tt> statement
at the top of the file loads the <tt>Test::Unit</tt> module: Ruby's
built-in unit testing framework.  The next line declares a class
called <tt>StringTest</tt>. The <tt>&lt;</tt> symbol on the class
declaration line means that <tt>StringTest</tt> is a subclass of
<tt>Test::Unit::TestCase</tt>.  Classes that are test cases must
extend <tt>Test::Unit::TestCase</tt> to enjoy the set of
computer-checked assertion methods that we'll use later. 

</p>




<p>

The <tt>StringTest</tt> class has one method: <tt>test_length</tt>.
Test methods take no parameters and they must be named with a
&quot;test&quot; prefix so that Test::Unit knows that they're tests we
want to run.  After defining the method, we create a variable called
<tt>s</tt> that references an object of class <tt>String</tt>.  We
don't have to declare the type of the variable because Ruby figures
out its type based on what the variable can do.  (More on this
exciting topic later.)  We then call the <tt>assert_equal</tt> method
(inherited from <tt>TestCase</tt>) with two parameters.  What we're
saying here is we expect the length of the string <tt>s</tt> to be 13.
Then the method definition ends with the <tt>end</tt> keyword, as does
the class definition.

</p>




<p>
Now, let's run the test.
</p>




<blockquote>
<pre>
> ruby string_test.rb
Loaded suite string_test
Started
.
Finished in 0.0051 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
</pre>
</blockquote>




<p> 

OK, so we can count!  Let's kick it up a notch.  Double-quoted strings
can also contain any Ruby expression of the form
<tt>#{expression}</tt>.  So let's add another test.

</p>




<blockquote>
<pre>
def test_expression_substitution
  assert_equal("", "#{'Hello! ' * 3}")
end
</pre>
</blockquote>




<p> 

Hmm, that's not going to pass.  We're asserting that the result of the
expression passed as the second parameter will equal an empty string.
We may not be sure what the expression will do, but we're pretty sure
it will evaluate to a non-empty string.  So why use <tt>""</tt> as the
expected value?

</p>




<p>

Sometimes when we're trying to learn something new, we just don't know
the answer.  We might have a guess, but if we trust the source then we
can do one better: we can ask.  By leaving the expected outcome empty,
we're asking Ruby to tell us what the answer is when we run the test.

</p>




<blockquote>
<pre>
> ruby string_test.rb 
Loaded suite string_test
Started
F.
Finished in 0.093141 seconds.

  1) Failure:
test_expression_substitution(StringTest) [string_test.rb:13]:
<""> expected but was
<"Hello! Hello! Hello! ">.

2 tests, 2 assertions, 1 failures, 0 errors
</pre>
</blockquote>




<p>

Ah, so that's how it works!  Thanks, Ruby!  It's pretty much what we
expected: Print the phrase &quot;Hello!&quot; three times.  Now we
plug that answer in, happy to have learned something new.

</p>




<blockquote>
<pre>
def test_expression_substitution
  assert_equal("Hello! Hello! Hello! ", "#{'Hello! ' * 3}")
end
</pre>
</blockquote>




<p>
With the answer recorded, we can re-run just that test method.
</p>




<blockquote>
<pre>
> ruby string_test.rb --name test_expression_substitution
Loaded suite string_test
Started
.
Finished in 0.005031 seconds.

1 tests, 1 assertions, 0 failures, 0 errors
</pre>
</blockquote>




<p> 

Wait just a doggone minute!  What did we just do?  We ran a test,
knowing it would fail, and then we picked out the answer from the
error and plugged it into the test so that it now passes.  You
wouldn't dare try this with code you were really <i>testing</i>!

</p>




<p>

We have no idea if Ruby did what it should have done: we just know
what it did.  That is, we used the language as a tool to explore
itself.  In the same way that a test is better than a specification,
the language is better than a description of the language.  The test
is definitive&#151;when we ask Ruby what the answer to <tt>'Hello! ' *
3</tt> is, we're going to the horse's mouth.  It doesn't matter what
the documentation says; what we're testing is what actually happens.
And that's learning.  So the test is both a learning test and a
regression test.

</p>




<h3>Now It's Your Turn</h3>




<p> 

We've barely scratched the surface of what the Ruby <tt>String</tt>
class can do.  See pages 61 and 606 of the book for a full listing of
all the methods and explanations for each.  You can also get a list of
all the messages that <tt>String</tt> responds to by typing: </p>




<blockquote>
<pre>
> ri String
</pre>
</blockquote>




<p> 

Indeed, there's a lot to learn, but these first tests give you a
framework to explore the many wonders of strings.  Better yet, you
have a safe learning environment and a language that makes it easy to
write and run tests.  So go ahead, write a few more string tests, then
run them and Ruby will tell you the answers.  Give <tt>gsub</tt> and
<tt>squeeze</tt> a poke.  It's just a start, but it may be more Ruby
code than you've written before. Next time we'll look at another facet
of Ruby through the eyes of learning tests.

</p>


<p><em>If you're interested in becoming fluent in Ruby, I recently released a comprehensive <a href="http://pragmaticstudio.com/ruby">online Ruby course</a> that includes 25 high-quality videos, a companion workbook of exercises, and more. It was a lot of fun to create, and I hope you enjoy it!</em></p>


	</div>
</div>
  
  <div id="more">
    Read more posts in the <a href="/blog/archive">blog archive</a> &raquo;
  </div>
</div>

</div>



</div> <!-- main -->

<div id="footer">
  Copyright &copy; 1999-2013 Mike Clark. All rights reserved. <a href="/usage">Usage Guidelines</a>
</div>

</div> <!-- wrapper -->

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-1226971-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>
