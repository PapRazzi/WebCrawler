{"name":"Webcrawler","tagline":"A (very primitive) web crawler in Python that attempts to do a limited crawl of the web.","body":"WebCrawler\r\n==========  by Jiankai and Zhuoran\r\n\r\nA (very primitive) web crawler in Python that attempts to do a limited crawl of the web.\r\n\r\nThe purpose is to learn about crawling and to learn a bit about the various strutures and features found in web pages and how to handle/parse them.\r\n\r\nHow does the program works and what are the major functions?\r\n\r\nGiven a query (a set of keywords) and a number n provided by the user, the crawler will contact Google, get the top-10\r\nresults for this query from Google, and then crawl starting from these top-10 results in a Breadth-First manner until\r\nwe have collected a total of n pages. Each page will be visited only once and stored in a file in the directory called\r\n\"pages\". The program will output a list of all visited URLs, in the order they are visited, into a file called\r\n\"visited\". In each line, in addition to the URL of the crawled page, we also print the time when it was crawled, its\r\nsize, and the return code (e.g., 200, 404). The program will also compute the total number and total size (in MB) of the\r\npages that were downloaded, and the depth of each page, i.e., its minimum distance from one of the 10 start pages, total\r\ntime, and number of 404 errors. (As start pages, we use the actual result URLs returned by Google.)\r\n\r\nA list of special features beyond the basic requirements:\r\n\r\n1. The program uses mutithreading technique to improve the overall performance of the web crawler.\r\n   In the worst case, the speed is .8 seconds per page.\r\n\r\n2. The program parses \"base\" elements.\r\n   It will get the base URL and use it for all relative URLs contained within a document.\r\n   It solves the issues of \"the ambiguity of URLs\".\r\n\r\n3. The program sends customized request headers to servers.\r\n   The Accept request-header field can be used to specify certain media types which are acceptable for the response.\r\n   Accept headers can be used to indicate that the request is specifically limited to a small set of desired types.\r\n   Only html and xhtml are acceptable for the response, in our case.\r\n   If the server cannot send a response which is acceptable according to the combined Accept field value, then the\r\n   server SHOULD send a 406 (not acceptable) response.\r\n\r\n4. The program is able to detect duplicate contents. Rather than save whole contents in memory, we prefer Sim-hash and hanging distance techniques. There are about 10% duplicate contents found in average.\r\n\r\n6. In practice, there are two problems of performance. First, some pages have tons of out-link. For this case, we do not\r\n   allow redundantly pushing url into queue. Second, some servers have long time delay. For this case, we are planning \r\n   set up a run-time which help jump out slow pages.\r\n\r\n7. We write CheckUrl, CheckContents and CheckSite functions independently. This is good for extend for future work. Two hash tables\r\n   are maintained in these two functions store visited url information and visited site information, including \r\n   arrival time, how many times, robot protocol, e.g.\r\n\r\n8. We are using GitHub for version control. We also build up a web page and a wiki page for this project. See\r\n   http://charnugagoo.github.com/WebCrawler/\r\n\r\nA list of the files in our submission and what they do:\r\n\r\n==========\r\n\r\nHow to compile and run this program?\r\n\r\n1. Launch your terminal.\r\n2. Enter the directory of the file \"WebCrawler.py\".\r\n3. Run the following command:\r\n\r\npython WebCrawler.py 'query' 500\r\n\r\nMeaning of input parameters:\r\nquery: (Required) A set of keywords to be searched. Query must be quoted, if there're more than one word in it.\r\nn: (Required) The total number of pages to be collected.\r\n\r\n\r\n\r\n===========\r\nFILE LISTS:\r\n\r\n1. WebCrawler.py\r\n\r\nThe main web crawler file.\r\nGiven a query (a set of keywords) and a number n provided by the user, the crawler will contact Google, get the top-10\r\nresults for this query from Google, and then crawl starting from these top-10 results in a Breadth-First manner until\r\nwe have collected a total of n pages.\r\n\r\n2. CheckUrl.py\r\n\r\ncheckUrl function checks if a url could be crawled. \r\n\r\n3.CheckSite.py\r\n\r\nGiven a url, check its root site's information, whether this url could be crawled. \r\n\r\n4. IndexFunc.py\r\n\r\nTreat url with \"index/main/default\" as the same without it.\r\n\r\n5. DeleteLastSlash.py\r\n\r\nDefine all urls without the last slash\r\n\r\n6. CheckRobots.py\r\n\r\nGiven a url, check its robots protocol.\r\n\r\n7. CheckContent.py\r\n\r\nCheck if two pages have the same/simialer contents, duplicate contents detecting.\r\n\r\n8. SimHashSample.py\r\n\r\nThe sim-hash function and hanging distance function used in CheckContent.py\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}