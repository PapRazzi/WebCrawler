<html>
<head>
		<title>
ONLamp.com: A Primer on Python Metaclass Programming</title>
        <script language="javascript" src="/common.js"></script>
<meta name="GOOGLEBOT" content="NOARCHIVE">
<meta name="ROBOTS" content="NOINDEX, NOFOLLOW">
</head>
<body  bgcolor="#ffffff" text="#000000">


<a href="http://www.onlamp.com/">

<img src="http://onlamp.com/images/onlamp/onlamp-logo.gif" alt="ONLamp.com" width="240" height="88" align="left" border="0" /></a>

<dummy>&nbsp;&nbsp;&nbsp;</dummy>

<br clear="all" />

&nbsp;<font face="verdana,arial,helvetica" size="1">Published on <b>

<a href="http://www.onlamp.com/">ONLamp.com</a></b> (<a href="http://www.onlamp.com/">http://www.onlamp.com/</a>)<br />

 <!-- ---------- End of PERL --------------------- -->

&nbsp;<a href="/pub/a/general/print_code.html">See this</a> if you're having trouble printing code examples</font><br /><br clear="all" />

<!-- ISI_LISTEN_START -->
<span class=ISI_MESSAGE>
<!--  
This article is brought to you by Oreilly Net, your source for all
Python 
 news.  -->
</span>    

<!--CS_PAGE_BREAK-->
<h2>
A Primer on Python Metaclass Programming</h2>
by <a href="/pub/au/1190">David Mertz</a><br />
04/17/2003
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->

<p> <i>This series of articles by David Mertz assumes readers have a familiarity
with basic object-oriented programming concepts: inheritance, encapsulation, and
polymorphism. We pick up where the basics leave off; how some "exotic"
techniques can make applied programming tasks easier, more maintainable, and just
plain more elegant.  This series will primarily present examples in Python, but
the concepts apply to other programming languages too.  </p>

<p> This first installment examines </i>metaclasses<i>.  Just as ordinary
instances (objects) are built out of classes, classes themselves are built out
of metaclasses. Most of the time, you do not need to worry about the implicit
metaclass (named <code>type</code> in Python) that is used in class
construction, but occasionally, deliberate control of a class' metaclass can
produce powerful effects. For example, metaclasses allow "aspect oriented
programming," meaning you can enhance classes with features like tracing
capabilities, object persistence, exception logging, and more.</i>  </p>

<h3>An Object-Oriented Programming Review</h3>

<!--
<csperl file="set_book_cover_image">
-->

<!-- sidebar begins -->
<table width="140" border="1" cellspacing="2" cellpadding="10" align="right" style="border: 1px solid #333333; margin: 8px;"><tr>
<td width="140" valign="top" bgcolor="#ffffff" style="border: none;">
<p class="headline">Related Reading</p>
<!--
<csif perl="$cfg->vars('cover_image_url_base')">
-->
<a href="http://shop.oreilly.com/product/9780596001889.do?CMP=ILL-4GV796923290">

<img src="http://covers.oreilly.com/images/9780596001889/cat.gif">

<!--

<csperl>print $cfg->vars('cover_image_url_cat');</csperl>
-->
</a>
<!--
</csif>
-->
<p class="medlist"><span class="title"><a href="http://shop.oreilly.com/product/9780596001889.do">Python in a Nutshell</a></span><strong><br />

By <a href="http://www.oreillynet.com/pub/au/918">Alex Martelli</a></strong>
</p>
<div class="secondary">
<!-- builds links to list in sidebar -->
<!--csperl>
    my @links = split(/(?:\r?\n)+/, ( $DATA{"supporting_links"} || "" ));
    for my $link ( @links ) {
	my ( $name, $url ) = split /=/, $link, 2;	
	next unless $name and $url;
	$url = "http://shop.oreilly.com/product/$DATA{'reference'}.do$url" unless $url =~ /^\w+:/os;
$url = $url . "?CMP=ILL-4GV796923290";
        if ($name =~ /Table of Contents/) {
           print qq~ <a href="$url">$name</a><br /> \n ~;
        } elsif ($name =~ /Index/) {
           print qq~ <a href="$url">$name</a><br /> \n ~;
        } elsif ($name eq "Author's Article") {
           print qq~ <a href="$url">$name</a><br /> \n ~;
        } elsif ($name =~ /Sample Chapter/) {
           print qq~ <a href="$url">$name</a><br /> \n ~;
        } else {
           print qq~\n~;
        }
    }
</csperl-->

</div>
</td>
</tr></table>
<!-- sidebar ends -->


<p> In general principles, OOP works the same way across many programming
languages, modulo minor syntax differences. In an object-oriented programming
language, you can define <em>classes</em> that bundle together related data
and behavior.  These classes can inherit some or all of their qualities from
their <em>parents</em>, but can also define attributes (data) or methods
(behavior) of their own. Classes generally act as templates for the creation of
<em>instances</em> (or simply <em>objects</em>). Different instances of the
same class typically have different data but share the same "shape"--e.g.,
the <code>Employee</code> objects <code>bob</code> and <code>jane</code> both
have a <code>.salary</code> and a <code>.room_number</code>, but not the same
room and salary as each other.  </p>

<h3>A Metaprogramming Rejoinder</h3>

<p> In Python (and other languages), classes are themselves objects that can be
passed around and introspected.   Just as regular classes act as templates for
producing instances, metaclasses act as templates for producing classes.  </p>

<p> Python has always had metaclasses. The metaclass machinery became exposed much better  with Python 2.2.  Specifically, with version 2.2, Python stopped
being a language with just one special (mostly hidden) metaclass that created
every class object. Now, programmers can subclass the built-in metaclass
<code>type</code> and even dynamically generate classes with varying
metaclasses.  </p>

<p> You do not need to use custom metaclasses to manipulate the production of
classes, however.  A slightly less brain-melting concept is a <em>class
factory</em>.  An ordinary function can return a class that is dynamically
created within the function body.  In traditional Python syntax, you can write the following.
</p>

<h4>Example 1. An old-fashioned Python 1.5.2 class factory</h4>

<pre><code>Python 1.5.2 (#0, Jun 27 1999, 11:23:01) [...]
Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
&gt;&gt;&gt; def class_with_method(func):
...     class klass: pass
...     setattr(klass, func.__name__, func)
...     return klass
...
&gt;&gt;&gt; def say_foo(self): print 'foo'
...
&gt;&gt;&gt; Foo = class_with_method(say_foo)
&gt;&gt;&gt; foo = Foo()
&gt;&gt;&gt; foo.say_foo()
foo</code></pre>

<p> The factory function <code>class_with_method()</code> dynamically creates
and returns a class that contains the method/function passed into the factory.
The class itself is manipulated within the function body before being returned.
The <strong><code>new</code></strong> module provides a more concise spelling,
but without the same options for custom code within the body of the class
factory: </p>

<h4>Example 2. A class factory in the <code><strong>new</strong></code>
module</h4>

<pre><code>&gt;&gt;&gt; from new import classobj
&gt;&gt;&gt; Foo2 = classobj('Foo2',(Foo,),{'bar':lambda self:'bar'})
&gt;&gt;&gt; Foo2().bar()
'bar'
&gt;&gt;&gt; Foo2().say_foo()
foo</code></pre>

<p> In all of these cases, the behaviors of the class (<code>Foo</code>,
<code>Foo2</code>) are not directly written as code, but are instead created by
calling functions at runtime, with dynamic arguments.  Not only are the
<em>instances</em> dynamically created, so are the <em>classes</em> themselves.
</p>

<h3>From Class Factories to Metaclasses</h3>

<p> Methods (i.e., of classes), like plain functions, can return objects. In
that sense, it is obvious that class factories can be classes just as easily as
they can be functions. In particular, Python 2.2+ provides a special class
called <code>type</code> that is just such a class factory. The new class
<code>type</code> is backwards-compatible with the older function of the same
name, by the way. The class <code>type</code> works as a class factory in the
same way that the function <code>new.classobj</code> does: </p>

<h4>Example 3. <code>type</code> as a class factory metaclass</h4>

<pre><code>&gt;&gt;&gt; X = type('X',(),{'foo':lambda self:'foo'})
&gt;&gt;&gt; X, X().foo()
(&lt;class '__main__.X'&gt;, 'foo')</code></pre>

<p> Since <code>type</code> is now a (meta)class, you are free to subclass it:
</p>

<h4>Example 4. A <code>type</code> descendent as class factory</h4>

<pre><code>&gt;&gt;&gt; class ChattyType(type):
...     def __new__(cls, name, bases, dct):
...         print "Allocating memory for class", name
...         return type.__new__(cls, name, bases, dct)
...     def __init__(cls, name, bases, dct):
...         print "Init'ing (configuring) class", name
...         super(ChattyType, cls).__init__(name, bases, dct)
...
&gt;&gt;&gt; X = ChattyType('X',(),{'foo':lambda self:'foo'})
Allocating memory for class X
Init'ing (configuring) class X
&gt;&gt;&gt; X, X().foo()
(&lt;class '__main__.X'&gt;, 'foo')</code></pre>

<p> The magic methods <code>.__new__()</code> and <code>.__init__()</code> are
special, but in conceptually the same way that they are for any other class. The
<code>.__init__()</code> method lets you configure the created object and the
<code>.__new__()</code> method lets you customize its allocation. The latter is
not widely overridden, but does exist for every Python 2.2 new-style class.
</p>

<p> There is one feature of <code>type</code> descendents to be careful about;
it catches everyone who first plays with metaclasses.  The first argument to
methods is conventionally called <code>cls</code> rather than
<code>self</code>, because the methods operate on the <em>produced</em> class,
not the metaclass.  Actually, there is nothing special about this.  All methods
attach to their instances, and the instance of a metaclass is a class.  A
better name makes this more obvious: </p>

<h4>Example 5. Attaching class methods to produced classes</h4>

<pre><code>&gt;&gt;&gt; class Printable(type):
...     def whoami(cls): print "I am a", cls.__name__
...
&gt;&gt;&gt; Foo = Printable('Foo',(),{})
&gt;&gt;&gt; Foo.whoami()
I am a Foo
&gt;&gt;&gt; Printable.whoami()
Traceback (most recent call last):
TypeError:  unbound method whoami() [...]</code></pre>

<p> All of this surprisingly non-remarkable machinery comes with some syntax sugar
that both makes working with metaclasses easier and confuses new users.  There
are several elements to the extra syntax.  The resolution order of these new
variations is tricky though.  Classes can inherit metaclasses from their
ancestors--notice that this is <strong>not</strong> the same thing as
<em>having</em> metaclasses as ancestors (another common confusion).  For
old-style classes, defining a global <code>__metaclass__</code> variable can
force a custom metaclass to be used.  Most of the time, the safest approach is
to set a <code>__metaclass__</code> class attribute for a class that wants to
be created via a custom metaclass.  You must set the variable in the class
definition itself, since the metaclass is not used if the attribute is set later
(after the class object has already been created).  For example: </p>

<h4>Example 6. Setting a metaclass with a class attribute</h4>

<pre><code>&gt;&gt;&gt; class Bar:
...     __metaclass__ = Printable
...     def foomethod(self): print 'foo'
...
&gt;&gt;&gt; Bar.whoami()
I am a Bar
&gt;&gt;&gt; Bar().foomethod()
foo</code></pre>

<table id="page-break" width="100%" border="0" cellspacing="0" cellpadding="0" style="clear:left;"><tr><td><p class="secondary">
<!--CS_PAGE_INDEX-->
</p></td><td><p class="secondary" align="right">
<a href="<!--CS_NEXT_REF-->">
 </a></p></td></tr></table>



<!--CS_PAGE_BREAK-->

<p>




<!--CS_PAGE_INDEX-->
</p>

<h3>Solving Problems with Magic</h3>

<p> So far, we have seen the basics of metaclasses.  Putting them to work is
more subtle.  The challenge of using metaclasses is that in typical OOP design,
classes do not really <em>do</em> much.  Class inheritance structures
encapsulate and package data and methods, but one typically works with
instances in the concrete.  </p>

<p> There are two general categories of programming tasks where I think
metaclasses are genuinely valuable.  </p>

<p> The first, and probably more common, category is where you do not know at
design time <em>exactly</em> what a class needs to do.  Obviously, you will
have some idea about it, but some particular detail might depend on information
that will not be available until later.  "Later" itself can be of two sorts: a),
when a library module is used by an application, and  b), at runtime when some
situation exists.  This category is close to what is often called "Aspect
Oriented Programming" (AOP).  Let me show an elegant example: </p>

<h4>Example 7. Metaclass configuration at runtime</h4>

<pre><code>% cat dump.py
#!/usr/bin/python
import sys
if len(sys.argv) &gt; 2:
    module, metaklass  = sys.argv[1:3]
    m = __import__(module, globals(), locals(), [metaklass])
    __metaclass__ = getattr(m, metaklass)

class Data:
    def __init__(self):
        self.num = 38
        self.lst = ['a','b','c']
        self.str = 'spam'
    dumps   = lambda self: `self`
    __str__ = lambda self: self.dumps()

data = Data()
print data

% dump.py
&lt;__main__.Data instance at 1686a0&gt; </code></pre>

<p> As you would expect, this application prints out a rather generic
description of the <code>data</code> object (a conventional instance).  We get
a rather different result by passing <em>runtime</em> arguments to the
application: </p>

<h4>Example 8. Adding an external serialization metaclass</h4>

<pre><code>% dump.py gnosis.magic MetaXMLPickler
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE PyObject SYSTEM "PyObjects.dtd"&gt;
&lt;PyObject module="__main__" class="Data" id="720748"&gt;
&lt;attr name="lst" type="list" id="980012" &gt;
  &lt;item type="string" value="a" /&gt;
  &lt;item type="string" value="b" /&gt;
  &lt;item type="string" value="c" /&gt;
&lt;/attr&gt;
&lt;attr name="num" type="numeric" value="38" /&gt;
&lt;attr name="str" type="string" value="spam" /&gt;
&lt;/PyObject&gt;</code></pre>

<p> The particular example uses the serialization style of
<code>gnosis.xml.pickle</code>, but the most current <code>gnosis.magic</code>
package also contains the metaclass serializers <code>MetaYamlDump</code>,
<code>MetaPyPickler</code>, and <code>MetaPrettyPrint</code>.  Moreover, a user of
the <code>dump.py</code> "application" can impose the use of any "MetaPickler"
she wishes, from any Python package that defines one.  Writing an appropriate
metaclass for this purpose will look something like this: </p>

<h4>Example 9. Adding an attribute with a metaclass</h4>

<pre><code>class MetaPickler(type):
    "Metaclass for gnosis.xml.pickle serialization"
    def __init__(cls, name, bases, dict):
        from gnosis.xml.pickle import dumps
        super(MetaPickler, cls).__init__(name, bases, dict)
        setattr(cls, 'dumps', dumps)</code></pre>

<p> The remarkable achievement of this arrangement is that the application
programmer need have no knowledge about what serialization will be used--nor
even whether serialization or some other cross-sectional capability will be
added <strong>at the command line</strong>.  </p>

<p> Perhaps the most common use of metaclasses is similar to that of
MetaPicklers: adding, deleting, renaming, or substituting methods for those
defined in the produced class.  In our example, a "native"
<code>Data.dump()</code> method is replaced by a different one from outside of the
application, at the time the class <code>Data</code> is created (and therefore,
in every subsequent instance).  </p>

<h3>Resources</h3>

<p> A useful book on metaclasses is <em>Putting Metaclasses to Work</em>, by
Ira R. Forman, Scott Danforth, Addison-Wesley 1999 (ISBN 0201433052).  </p>

<p> For metaclasses in Python specifically, Guido van Rossum's essay, "<a href="http://www.python.org/2.2/descrintro.html"> Unifying types and classes in
Python 2.2</a>," is useful.  </p>

<p> My <a href="http://gnosis.cx/download/Gnosis_Utils-current.tar.gz">Gnosis
Utilities package</a> contains functions to make working with metaclasses
easier and more powerful.  </p>

<p><i>
<a href="/pub/au/1190">David Mertz</a> 
, being a sort of Foucauldian Berkeley, believes, <em>esse est
denunte</em>.

</i></p>

<hr size="1" noshade />

<p>Return to <a href="/python/">Python DevCenter</a>.</p>




<p><font face="verdana,arial,helvetica" size="1">Copyright &copy; 2009 O'Reilly Media, Inc.</font></p>

<!-- ISI_LISTEN_STOP -->  

<!-- path_info: /a/3388 -->
<!-- table: a - ref_id: /3388 -->
<!-- table: a - ref_id: /3388 -->
<!-- table: a - ref_id: /3388 - cs_rid:  -->
</body>


</html>
