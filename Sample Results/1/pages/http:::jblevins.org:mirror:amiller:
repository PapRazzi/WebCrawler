<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Alan Miller's Fortran Software</title>
  <style type="text/css">
    h1, h2, h3, .back, .center { text-align: center; }
  </style>
</head>

<body>

<h1 id="top">Alan Miller's Fortran Software</h1>

<p class="center">[
<a href="#subset">Subset Selection</a> |
<a href="#random">Random Number Generation</a> |
<a href="#quad">Quad Precision</a> |
<a href="#apstat">Applied Statistics Algorithms</a> |
<a href="#logit">Logistic Regression</a> |
<a href="#toms">TOMS Algorithms</a> |
<a href="#nswc">Naval Surface Warfare Center Code</a> |
<a href="#misc">Miscellaneous</a> |
<a href="#nas">10-Byte Reals for NAS FortranPlus</a> |
<a href="#f">F code</a> |
<a href="#lsq">Linear Least Squares</a> |
<a href="#links">Links</a> ]
</p>

<p>This is an archived copy of the Fortran source code repository of
<a href="mailto:amiller@bigpond.net.au">Alan Miller</a> previously
located at <code>http://users.bigpond.net.au/amiller/</code>. It is
hosted by <a href="http://jblevins.org/">Jason Blevins</a> with
permission. The site has been slightly reformatted, but the source
code and descriptions below have not been modified.</p>

<p>All code written by Alan Miller is released into the public
domain.  Code written by other authors or from other sources (e.g.,
academic journals) may be subject to other restrictions.</p>

<hr />

<h2 id="subset">Subset Selection in Regression</h2>

<p>The 2nd edition of my book on this subject was published by CRC
Press (Chapman &amp; Hall) in April 2002 (ISBN 1-58488-171-2). Dr.
David Smith from the Medical College of Georgia, USA, has notified
me of certain missing references. Here they are in <a href="add_refs.ps">postscript</a> and <a href="add_refs.pdf">pdf</a>
formats.</p>

<p>As I can no longer access my ozemail web site, I shall make the
latest versions of my subsets software available here.</p>

<ul>
<li>
<p><a href="lsq.f90">lsq.f90</a> is the latest version of my
uncontrained weighted least-squares module. It is an upgraded
version of Applied Statistics algorithm AS 274. It uses planar
rotations to produce an upper-triangular factorization. The routine
INCLUD is called once for each case in the data set. It is suitable
for situations in which the least-squares calculations have to be
updated each time more observations become available. It has
routines for automatically setting up tolerances and testing for
singularities. It uses a version of rank-revealing QR decomposition
for this. This code is now compatible with ELF90.</p>
<p>If results for a subset of predictor variables are required,
those variables are moved to the first positions, and variables to
be excluded are ordered after them. Routine VMOVE moves one
variable; routine REORDR re-orders the variables so that those
listed are in the first positions, though not necessarily in the
order specified.</p>
<p>For further details on how to use the module and on methods of
least-squares calculation refer to the document <a href="lsq.txt">lsq.txt</a>.</p>
<p>There is a <a href="lsq_demo.f90">DEMO program</a> which uses a
simple data set <a href="fuelcons.dat">fuelcons.dat</a>, and a
nasty test program <a href="test1.f90">test1.f90</a>.</p>
<p>If you want to see more tests then download the zip file
<a href="tests.zip">tests.zip</a> and the set of data files used by
these tests in <a href="testdata">testdata</a>.</p>
</li>
<li>
<p><a href="find_sub.f90">find_sub.f90</a> is a module for finding
subsets of variables using a variety of different algorithms.</p>
</li>
<li>
<p><a href="subset.f90">subset.f90</a> is a driver program which
uses the above two modules. I have also made available the data set
<a href="pollute.dat">pollute.dat</a> of mortality rates against
socio-economic, meteorological and pollution variables for 60
statistical areas in the USA.</p>
</li>
</ul>

<p>For subset selection using the L1-norm, that is minimizing the
sum of absolute residuals, here is <a href=
"toms615.f90">toms615.f90</a> which is a translation of TOMS
algorithm 615 to make it ELF90 compatible. There is also a driver
program <a href="test615.f90">test615.f90</a>, some test data
<a href="test615.dat">test615.dat</a>, and the expected output
<a href="test615.out">test615.out</a>.</p>
<p>For linear regression, but when the regression coefficients must
be positive or zero, there is the Lawson &amp; Hanson non-negative
least-squares routine <a href="nnls.f90">nnls.f90</a>. N.B. Two
call arguments have been removed from the Fortran 77 version. This
routine is ELF90-compatible.</p>
<p>I have also added my own <a href="nonnegls.f90">nonnegls.f90</a>
routine which is called after a QR-factorization has been formed
using module LSQ. The file <a href="t_nnls.f90">t_nnls.f90</a> uses
both of these routines.</p>
<p class="back"><a href="#top">Back to top</a></p>

<hr />

<h2 id="random">Uniform Random Number Generation</h2>

<ul>
<li><a href="luxury.f90">luxury.f90</a> Another generator of
uniformly distributed random numbers. <a href=
"luxtst.f90">luxtst.f90</a> A program to test luxury.f90.</li>
<li><a href="taus88.f90">taus88.f90</a> L'Ecuyer's 1996 Tausworthe
random number generator, and <a href="lfsr113.f90">lfsr113.f90</a>
L'Ecuyer's 1999 Tausworthe random number generator. The first has a
cycle of 2^88 while the second is a little slower but has a cycle
of 2^113. Both are translations from C. N.B. These both assume that
default integers are 32-bit.</li>
<li><a href="lfsr258.f90">lfsr258.f90</a> A 64-bit random number
generator from Pierre L'Ecuyer with a cycle of about 2^258 or more
than 10^77.</li>
<li><a href="dprand.f90">dprand.f90</a> Nick Maclaren's double
precision random number generator, translated into ELF90-compatible
form.</li>
<li><a href="mt19937.f90">mt19937.f90</a> The 'Mersenne Twister'
random number generator from Japan with a cycle of length (2^19937
- 1). <a href="mt19937a.f90">mt19937a.f90</a> is a version for
compilers which stop when there are integer overflows, as some do
when compiler check options are enabled for debugging purposes.
Before using this module, you are advised to scan the <a href=
"http://www.math.keio.ac.jp/~matumoto/emt.html">Japanese web
site</a> particularly under `Initialization'. mt19937.f90 was
revised on 5 February 2002; mt19937a.f90 has not been revised.</li>
<li><a href="rand3.f90">rand3.f90</a> Yet another random number
generator; this one is based upon an algorithm by Donald Knuth
(1997).</li>
<li><a href="freq2d.f90">freq2d.f90</a> Pairs of uniform random
numbers should be uniformly distributed in the unit square. This is
a simple test program which failed using a new (1998) compiler.
ELF90-compatible.</li>
</ul>

<p class="back"><a href="#top">Back to top</a></p>

<hr />

<h2>Random numbers from other distributions</h2>

<ul>
<li><a href="random.f90">random.f90</a> A module for generating
random numbers from a range of distributions. There is a test
program <a href="t_random.f90">t_random.f90</a>. Another library
for random number generation can be found at <a href=
"http://biostatistics.mdanderson.org/SoftwareDownload/SingleSoftware.aspx?Software_Id=27">
randlib</a>.</li>
<li><a href="ran_norm.f90">ran_norm.f90</a> and <a href=
"rnorm.f90">rnorm.f90</a> Generate random numbers from the standard
normal distribution. ran_norm uses more random number calls, but
rnorm uses more logarithms and square roots. On those
machine/compiler combinations which have been tested recently,
rnorm has usually been faster (5-20%).</li>
<li><a href="r_gamma.f90">r_gamma.f90</a> and <a href=
"rgamma.f90">rgamma.f90</a> Generate random numbers from the gamma
distribution. The first routine is adapted from Dagpunar's book,
while the second is by Marsaglia and Bray.</li>
<li><a href="ignpoi.f90">ignpoi.f90</a> Generate random Poisson
deviates. Requires ran_exp.f90.</li>
<li><a href="ran_exp.f90">ran_exp.f90</a> Generate random
exponential deviates, simple method.</li>
<li><a href="toms780.f90">toms780.f90</a> Generate random
exponential deviates; two algorithms from TOMS algorithm 780.</li>
<li><a href="test780.f90">test780.f90</a> A program to compare
speeds of 3 different generators.</li>
<li><a href="t_kemp_b.f90">t_kemp_b.f90</a> Generate random
binomial deviates, including a small driver program.</li>
<li><a href="zipf.f90">zipf.f90</a> Generate discrete random
deviates having the Zipf (or zeta) distribution, with a small test
program.</li>
<li><a href="r_hyperg.f90">toms668.f90</a> The file for
r_hyperg.f90 contains TOMS algorithm 668 for generating random
values from the hypergeometric distribution.</li>
<li><a href="ziggurat.f90">ziggurat.f90</a> George Marsaglia's
functions for generating random samples from the uniform, normal
and exponential distributions. Translated from C.</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="quad">Quadruple precision</h2>

<p>There are multiple-precision (MP) software packages available
when double precision is not adequate, but these are extremely
slow. Quadruple precision gives about twice as many accurate digits
as double precision and is much faster than MP.</p>
<ul>
<li><a href="quad.f90">quad.f90</a> Module for quadruple precision
arithmetic on PC's, using operator overloading. This is designed
for use with Lahey's LF90 compiler (you must use -o0, i.e. no
optimization) or with Lahey's ELF90. For Compaq Visual Fortran 5.0
there is a separate version, <a href="quad_df.f90">quad_df.f90</a>,
of the main module now for Compaq which gives the same accuracy as
Lahey's. This version works with SOME Unix f90 compilers and with
Absoft Pro Fortran (Windows version) and NAS FortranPlus. For F
(another subset of F90), Windows 95 version, there is <a href=
"quad.f">quad.f</a>. For the Lahey/Fujitsu LF95 compiler, use the
Compaq version. N.B. Quadruple precision is built into LF95. It is
easier to use than this version, and more accurate (about 1.8
decimals), but slower.<br />
I have learnt that Visual Basic sets the FPU in the same way as
LF90 and F. If you are calling DLL's compiled in Fortran from VB,
it may be necessary to use quad.f90 even though quad_df.f90 is the
correct module for your Fortran compiler. This problem is likely to
occur with other mixed language programming. With the Portland
PGF90 compiler, I am told that you can use quad_df.f90, but you
must use the undocumented flags -Kieee and -PC 64, to `turn off
optimization'.</li>
<li>There is a short test program <a href=
"t_quad.f90">t_quad.f90</a>, for testing the basic arithmetic
operations (+-*/), and other test programs <a href=
"t_cubert.f90">t_cubert.f90</a>, <a href="t_cst.f90">t_cst.f90</a>
and <a href="t_logexp.f90">t_logexp.f90</a> for testing logs,
exponential and trigonometric functions. To test the F version, use
<a href="t_quad.f">t_quad.f</a>.</li>
<li><a href="qcomplex.f90">qcomplex.f90</a> Module for complex
quad. prec. arithmetic.</li>
<li>From time to time I receive e-mail messages telling me that the
quad. precision constants in my package are wrong. Before you do
the same, look at <a href="prtconst.f90">prtconst.f90</a>.</li>
<li>There are several example programs - <a href=
"hilbert.f90">hilbert.f90</a>, which inverts a 10 x 10 Hilbert
matrix, <a href="long_gj.f90">long_gj.f90</a>, for Gauss-Jordan
elimination and <a href="sym_eig.f90">sym_eig.f90</a> which finds
the eigenvalues and vectors of a symmetric matrix using Kaiser's
method.</li>
<li><a href="q_erf.f90">q_erf.f90</a> is a subroutine for
calculating the error function and its complement in quadruple
precision. Use <a href="q_erf.f">q_erf.f</a> if you are using
F.</li>
<li><a href="q_lngam.f90">q_lngam.f90</a> is a function for the log
of the gamma function.</li>
<li><a href="hero.f90">hero.f90</a> A program for calculating
coefficients for half-Hermite integration.</li>
<li>Polynomial equations can be extremely difficult to solve, and
this is one place where extra precision is often required. <a href=
"q_pzeros.f90">q_pzeros.f90</a> is a module for solving polynomial
equations, while <a href="q_poly20.f90">q_poly20.f90</a> provides
an example program. Requires the qcomplex module. <a href=
"#pzeros">Click here</a> for more details, and a link to a multiple
precision program.</li>
</ul>
<p>I am indebted to Keith Briggs (previouly at University of
Cambridge) for access to his package in C++ for quadruple precision
which helped improve the algorithm for calculating
exponentials.</p>
<p>There is a newer package for double-double precision and
quad-double precision (about 64 decimal digits accuracy) in C++,
which has a Fortran front-end, at <a href=
"http://crd.lbl.gov/~dhbailey/mpdist/">Click here</a>.</p>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="apstat">Some Applied Statistics Algorithms</h2>

<p>For many years, the Royal Statistical Society published
algorithms in its journal `Applied Statistics'. I have translated a
few of these to F90.</p>
<ul>
<li><a href="as6.f90">as6.f90</a> Cholesky factorization of
symmetric positive definite matrix with only lower triangle stored
as a vector (2 versions).</li>
<li><a href="as7.f90">as7.f90</a> Inversion of symmetric positive
definite matrix with only lower triangle stored as a vector using
AS6 (2 versions). Includes short test program and interfaces.</li>
<li><a href="as27.f90">as27.f90</a> Upper tail area under Student's
t-distribution.</li>
<li><a href="as60.f90">as60.f90</a> Calculates the
eigenvalues/vectors of a real symmetric matrix.</li>
<li><a href="as63.f90">as63.f90</a> Computes the incomplete beta
function. The file includes a module for the log of the beta
function, which also has the log of the gamma function.</li>
<li><a href="as66.f90">as66.f90</a> Area under the normal
curve.</li>
<li><a href="as91.f90">as91.f90</a> Returns percentage points of
the chi-squared distribution for input tail probabilities and
numbers of degrees of freedom.</li>
<li><a href="as110.f90">as110</a> Lp-norm fitting of straight
lines, particularly for 1 &lt;= p &lt;= 2, by extension of an
algorithm of Schlossmacher.</li>
<li><a href="chirp.f90">chirp.f90</a> The CHIRP-Z Fast Fourier
transform for series of arbitrary length. Refer to the journal
article for instructions on its use. Includes FFT for the usual
case when series length is a power of 2. this is AS120.</li>
<li><a href="as126.f90">as126</a> Calculates the distribution
function for the range for a sample of size n from the standard
normal distribution.</li>
<li><a href="as132.f90">as132.f90</a> Minimize the sum of absolute
deviations for a simple Y on X linear regression.</li>
<li><a href="as135.f90">as135.f90</a> Min-Max (L-infinity)
estimates for linear multiple regression, includes a test
program.</li>
<li><a href="as136.f90">as136.f90</a> A K-means clustering
algorithm.</li>
<li><a href="as152.f90">as152.f90</a> Cumulative hypergeometric
probabilities.</li>
<li><a href="as154.f90">as154.f90</a> Combines AS 154 &amp; 182,
for the exact maximum likelihood estimation of parameters of ARIMA
models using Kalman filtering.</li>
<li><a href="as155.f90">as155.f90</a> Distribution of a linear
combination of non-central chi-squared random variables. This code
is NOT compatible with Lahey's ELF90 compiler.</li>
<li><a href="as157.f90">as157.f90</a> The runs-up and runs-down
tests.</li>
<li><a href="as177.f90">as177.f90</a> Calculates the expected
values of normal order statistics.</li>
<li><a href="as181.f90">as181.f90</a> Calculates the Shapiro-Wilks
statistic and its P-value. Actually uses ASR94.</li>
<li><a href="as190.f90">as190.f90</a> Distribution function and its
inverse, for the studentized range.</li>
<li><a href="as192.f90">as192.f90</a> Computes approximate
significance points of a Pearson curve with given first four
moments, or first three moments and left or right boundary.</li>
<li><a href="as205.f90">as205.f90</a> Enumeration of all R x C
contingency tables with given row and column totals, and
calculation of hypergeometric probability for each table.</li>
<li><a href="as207.f90">as207.f90</a> Fits a general log-linear
model. N.B. The F90 version has NOT been tested by me (Alan
Miller).</li>
<li><a href="as217.f90">as217.f90</a> Does the dip calculation for
an ordered vector X using the greatest convex minorant and the
least concave majorant, skipping through the data using the change
points of these distributions. It returns the dip statistic 'DIP'
and the modal interval (XL, XU).</li>
<li><a href="as227.f90">as227.f90</a> Generates all possible N-bit
binary codes.</li>
<li><a href="as239.f90">as239.f90</a> Integral of the gamma
distribution</li>
<li><a href="as241.f90">as241.f90</a> Calculate the normal deviate
(z-score) corresponding to a given area under the normal curve</li>
<li><a href="as245.f90">as245.f90</a> Log of the gamma
function</li>
<li><a href="as260.f90">as260.f90</a> Calculates the distribution
function of the square (R^2) of the multiple correlation
coefficient.</li>
<li><a href="as261.f90">as261.f90</a> Quantiles of the distribution
of R^2.</li>
<li><a href="as275.f90">as275.f90</a> Calculation of the
non-central chi-squared distribution function.</li>
<li><a href="as282.f90">as282.f90</a> Robust regression using the
least median of squares (LMS) criterion. There is also a test
program: <a href="t_as282.f90">t_as282.f90</a></li>
<li><a href="as285.f90">as285.f90</a> Multivariate normal
probabilities over regions defined in a user-supplied
function.</li>
<li><a href="as286.zip">as286.zip</a> Parameter estimation for
non-linear errors-in-variables problems. I have added a third
example, fitting a cylinder, to the two which were in the published
version. This is a ZIP file.</li>
<li><a href="as290.f90">as290.f90</a> Generates a rectangular grid
which can be used for contour plotting of confidence limits in
nonlinear regression. Also outputs the F-values for the confidence
levels selected. The test program: <a href=
"t_as290.f90">t_as290.f90</a> produces the grid for the beanroot
data used in the paper in Applied Statistics: <a href=
"beanroot.dat">beanroot.dat</a></li>
<li><a href="dopt.f90">as295.f90</a> Algorithm for generating
designs of experiments which are close to D-optimal. The user
supplies the set of NCAND candidate design points and the algorithm
picks a subset of N of them. Tha main uses of this algorithm are
likely to be for choosing designs in situations in which there are
blocks of an awkward size, and for augmenting an experiment which
has already been carried out. Two driver programs are provided
here: <a href="fr_fac23.f90">fr_fac23.f90</a> for 2^p x 3^q
fractional factorial experiments with possibly unequal block sizes,
and <a href="ibquad.f90">ibquad.f90</a> for quadratic surface
designs with possibly unequal block sizes.</li>
<li><a href="as298.f90">as298.f90</a> Hybrid minimization routine
using simulated annealing and a user-supplied local minimizer. You
should also look at Dr. Tibor Csendes' global optimization
package.</li>
<li><a href="as304.f90">as304.f90</a> Fisher's non-parametric
randomization test for two small independent random samples.</li>
<li><a href="as310.f90">as310.f90</a> Incomplete beta
function.</li>
<li><a href="as319.f90">as319.f90</a> Variable metric unconstrained
function minimization without derivatives.</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="logit">Logistic Regression</h2>

<p>I have received several requests for Fortran code to perform
logistic regression, that is to fit:</p>
<p class="center">p = F/(1 + F)<br />
where<br />
p = the probability that a case is in one of two categories<br />
F = exp(b0 + b1.X1 + b2.X2 + ... + bk.Xk)<br />
X1, X2, ..., Xk is a set of k predictors, and<br />
b0, b1, b2, ..., bk is a set of coefficients to be fitted.
</p>
<ul>
<li><a href="logistic.f90">logistic.f90</a> Module for performing
the weighted least squares calculations. It requires my least
squares module <a href="lsq.f90">lsq.f90</a></li>
<li><a href="t_lgstc1.f90">t_lgstc1.f90</a> Driver program which
uses the data set <a href="birthwt.dat">birthwt.dat</a> from
Appendix 1 of Hosmer &amp; Lemeshow's book `Applied Logistic
Regression'.</li>
<li><a href="t_lgstc2.f90">t_lgstc2.f90</a> Driver program which
uses the data set <a href="surgical.dat">surgical.dat</a>. This
illustrates the use of logistic regression with grouped data. There
is an error in the published data (deliberately NOT corrected here)
which has caused grief with several well-known statistical
packages.</li>
<li><a href="t_lgstc3.f90">t_lgstc3.f90</a> Driver program which
uses the data set <a href="clearcut.dat">clearcut.dat</a>. This
illustrates the case in which there is a linear boundary such that
all cases on one side are in one category, and all cases on the
other side are in the other category.</li>
<li><a href="se_lgstc.f90">se_lgstc.f90</a> The standard errors
reported by logistic.f90 are often larger than those reported by
other packages for logistic regression. This simple simulation
program shows that those reported here are about right. It also
illustrates the bias in the slope parameters (they are always
biased towards being too large).</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="toms">Miscellaneous TOMS (and CACM) algorithms</h2>

<p>N.B. I have been asked to provide a link to the <a href=
"http://www.acm.org/pubs/copyright_policy/softwareCRnotice.html">copyright
policy of the ACM</a>. Loosely paraphrased, this allows use, and
modification, of the TOMS algorithms for most non-commercial
purposes. It also emphasizes that the ACM accepts no responsibility
for the accuracy of the code.</p>
<p>I have updated some of the Transactions on Mathematical Software
(TOMS) algorithms to Fortran 90.</p>
<ul>
<li><a href="cacm125.f90">cacm125.f90</a>. Calculate ordinates and
weights for Gaussian integration.</li>
<li><a href="cacm395.f90">cacm395.f90</a>. Calculate 2-tailed
probabilities from Student's t distribution.</li>
<li><a href="cacm396.f90">cacm396.f90</a> calculates quantiles of
the t-distribution. These are translations of Geoff Hill's algol
code; Geoff was acting chief of CSIRO Division of Mathematical
Statistics at one time. There is also a test program which may be
useful <a href="test395.f90">test395.f90</a>.</li>
<li><a href="cpoly.f90">cpoly.f90</a> This is the classic Jenkins
&amp; Traub algorithm (CACM 419) for the solution of complex
polynomials. <a href="q_cpoly.f90">q_cpoly.f90</a> is a version in
quadruple precision.</li>
<li><a href="rpoly.f90">rpoly.f90</a> TOMS algorithm 493 for the
solution of polynomial equations with real coefficients. <a href=
"q_rpoly.f90">q_rpoly.f90</a> is a version in quadruple
precision.</li>
<li><a href="toms513.f90">toms513.f90</a> In situ transpose of an
MxN matrix.</li>
<li><a href="toms519.f90">toms519.f90</a> Kolmogorov-Smirnov
probabilities.</li>
<li><a href="toms530.f90">toms530.f90</a> Eigenvalues &amp; vectors
of real skew-symmetric matrices (i.e. a(i,j) = -a(j,i) ), and of
symmetric matrices with zero diagonal elements.</li>
<li><a href="toms533.zip">toms533.zip</a> A simple package for the
solution of sparse linear equations. It is even shorter and simpler
in Fortran 90 as the user does not supply work arrays. The zipped
file (use PKUNZIP or WinZip to access the contents) contains two
demo programs. The second of these contained an error in the F77
version, and the solution vector was completely wrong.</li>
<li><a href="toms615.f90">toms615.f90</a> Fitting linear regression
models by minimizing the sum of absolute deviations. i.e. using the
L_1 norm. There are also, a short test program:</li>
<li><a href="test615.f90">test615.f90</a> A data file for the test
program:</li>
<li><a href="test615.dat">test615.dat</a> and a file showing the
output:</li>
<li><a href="test615.out">test615.out</a></li>
<li><a href="toms639.f90">toms639.f90</a> Integration from zero to
infinity of oscillating functions. Includes driver program.</li>
<li><a href="toms642.zip">toms642.zip</a> Fit a cubic spline to
noisy data using generalized cross-validation. Data may be unevenly
spaced, and have different weights. Bayesian point error estimates
are generated.</li>
<li><a href="fexact.zip">fexact.zip</a> (TOMS 643) Fisher's exact
test for two-way contingency tables. This is a zipped file
including a driver, data sets, and output. Use pkunzip or winzip to
unpack the files.</li>
<li><a href="toms644.zip">toms644.zip</a> Bessel and Airy functions
for complex arguments. This is a zipped file including test
programs. Use pkunzip or winzip to unpack the files.</li>
<li><a href="inc_gam.f90">toms654</a> The incomplete gamma function
and its inverse. Test program: <a href=
"t_incgam.f90">t_incgam.f90</a></li>
<li><a href="toms660.f90">toms660.f90</a> Quadratic spline
interpolation of a bivariate function defined by irregularly spaced
data.</li>
<li><a href="toms661.f90">toms661.f90</a> Quadratic spline
interpolation of a trivariate function defined by irregularly
spaced data.</li>
<li><a href="toms655.zip">toms655.zip</a> IQPACK (Interpolation /
Quadrature). Calculates nodes and weights for 8 types of Gaussian
quadrature (Legendre, Chebyshev, Hermite, rational polynomial,
etc.).</li>
<li><a href="toms667.f90">toms667.f90</a> Global minimization using
a stochastic algorithm, with 37 test problems <a href=
"test667.f90">test667.f90</a>. Many of the test problems require
hundreds of thousands of function evaluations. See also global.f90
below in the miscellaneous code section.</li>
<li><a href="r_hyperg.f90">toms668.f90</a> The file for
r_hyperg.f90 contains TOMS algorithm 668 for generating random
values from the hypergeometric distribution.</li>
<li><a href="toms683.f90">toms683.f90</a> The exponential integral
En(x) for complex argument x.</li>
<li><a href="toms703.f90">toms703.f90</a> A package for the
solution of systems of ordinary differential equations: DY/DT =
F(Y,T). There is also a test program: <a href=
"test703.f90">test703.f90</a></li>
<li><a href="toms707.f90">toms707.f90</a> Confluent hypergeometric
function for complex arguments.</li>
<li><a href="toms715.zip">toms715.zip</a> Special functions by W.J.
Cody and others. Particularly Bessel functions, but also the gamma,
normal distribution, error, Dawson and psi functions.</li>
<li><a href="toms725.f90">toms725.f90</a> Multivariate normal
integrals for dimension up to 20.</li>
<li><a href="toms726.zip">toms726.zip</a> Walter Gautschi's package
for generating orthogonal polynomials and Gauss-type quadrature
rules. The zip file contains a double precision, and most of the
single precision code, plus the set of 11 test programs and
Gautschi's output.</li>
<li><a href="toms751.f90">toms751.f90</a> Renka's TRIPACK package
for constrained 2D Delaunay triangulation, including test program
(with built-in data) and output files.</li>
<li><a href="toms757.zip">toms757.zip</a> Code for computing some
uncommon special functions, including Abramowitz functions, Airy
function variants, integrals of zero-order Bessel functions, Debye
functions, Struve functions, Synchrotron radiation and transport
functions, Lobachevski and Stromgen integrals, etc. A test program
is included. This is a zip file.</li>
<li><a href="toms760.f90">toms760.f90</a> Bicubic interpolation
from a rectangular grid of data. There is also a test program:
<a href="test760.f90">test760.f90</a></li>
<li><a href="toms766.zip">toms766.zip</a> Code for computing
Pade'-Hermite and simultaneous Pade' approximants, plus two driver
programs.</li>
<li><a href="toms778.zip">toms778.zip</a> This subroutine solves
bound-constrained optimization problems by using the compact
formula of the limited memory BFGS updates.</li>
<li><a href="tensolve.zip">tensolve.zip</a> This contains both TOMS
739 (UNCMIN) for unconstrained minimization, and TOMS 768
(TENSOLVE) for the solution of sets of non-linear equations.</li>
<li><a href="toms790.zip">toms790.zip</a> Cubic interpolation of
scattered data in two dimensions with continuous second
derivatives.</li>
<li><a href="toms796.zip">toms796.zip</a> This package is for the
numerical inversion of Laplace transforms. The original was in very
poor Fortran 77 which used many non-standard features, and it
contained many bugs. Each compiler I tried gave different errors,
and then different results when the errors were corrected. This
version is in standard Fortran and gives reproducible results.</li>
<li><a href="toms813.zip">toms813.zip</a> This package is for local
minimization, with or without convex constraints. It requires the
user to supply first derivatives. This version is in standard
Fortran. It uses the so-called spectral projected gradient (SPG)
method.</li>
<li><a href="toms819.zip">toms819.zip</a> This is for the
computation of the Airy functions Ai(z) and Bi(z) and their
derivatives for complex arguments.</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="nswc">Code converted from the<br />
Naval Surface Warfare Center Math. Library</h2>

<ul>
<li><a href="cgamma.f90">cgamma.f90</a> Complex gamma
function.</li>
<li><a href="erf.f90">erf.f90</a> The error function.</li>
<li><a href="dcerf.f90">dcerf.f90</a> Complex error function &amp;
its complement.</li>
<li><a href="cexpli.f90">cexpli.f90</a> Exponential integral for
complex argument.</li>
<li><a href="cbsslj.f90">cbsslj.f90</a> Complex Bessel function
J_{\nu}(z) where both the argument, z, and the order, \nu, are
complex.</li>
<li><a href="dple.f90">dple.f90</a> Solution of systems of linear
equations using the Henderson-Wassyng partial pivot algorithm.
Includes a test program to solve 100 simultaneous equations. The
user must provide a subroutine to supply any requested row of the
matrix.</li>
<li><a href="dspslv.f90">dspslv.f90</a> Solution of sparse systems
of linear equations using Gaussian elimination.</li>
<li><a href="dsvdc.f90">dsvdc.f90</a> Calculates the singular-value
decomposition (SVD) of a real matrix. There is also a test program:
--</li>
<li><a href="t_svd.f90">t_svd.f90</a></li>
<li><a href="fft.f90">fft.f90</a> Fast Fourier Transform (FFT) for
any length of series which has no prime factor greater than 23.
Also the inverse and multivariate FFT.</li>
<li><a href="hbrd.f90">hbrd.f90</a> Solve sets of non-linear
equations using Powell's Hybrid algorithm.</li>
<li><a href="specfunc.zip">specfunc.zip</a> A zip file containing
all of the special functions from the NSWC library.</li>
<li><a href="polyarea.f90">polyarea.f90</a> Calculates the area of
a polygon.</li>
<li><a href="p_intcpt.f90">p_intcpt.f90</a> Finds the crossing
points of a finite line and a polygon.</li>
<li><a href="bnd_solv.f90">bnd_solv.f90</a> Solve banded linear
equations using compact storage of the banded matrix. There is a
complex version of this -- <a href=
"cbnd_slv.f90">cbnd_slv.f90</a></li>
<li><a href="big_solv.f90">big_solv.f90</a> Solves a large set of n
general linear equations using out-of-core methods, requiring
storage for about n^2/4 values.</li>
<li><a href="qagi.f90">qagi.f90</a> Adaptive one-dimensional
integration over infinite or semi-infinite ranges (adapted from
QUADPACK).</li>
<li><a href="qxgs.f90">qxgs.f90</a> Adaptive one-dimensional
integration over finite ranges (adapted from TOMS algorithm
691).</li>
<li><a href="inc_gam.f90">inc_gam.f90</a> The incomplete gamma
function and its inverse. Test program: <a href=
"t_incgam.f90">t_incgam.f90</a> based on TOMS algorithm 654.</li>
<li><a href="constant.f90">constant.f90</a> This is a module of
constants used by some of the functions in the NSWC collection of
routines.</li>
<li><a href="qsortd.f90">qsortd.f90</a> A subroutine which
implements a quicksort algorithm without changing the input array.
It returns an integer array containing the order.</li>
<li><a href="smplx.f90">smplx.f90</a> Linear programming using the
simplex algorithm. This is a translation of the Fortran 66 program
from the NSWC (Naval Surface Warfare Center) library written by
Alfred Morris. There is also a simple test program <a href=
"t_smplx.f90">t_smplx.f90</a>. Needs the module <a href=
"constant.f90">constant.f90</a> which defines the precision and
returns certain machine constants.</li>
<li><a href="dmexp.f90">dmexp.f90</a> Calculates the exponential of
a matrix.</li>
<li><a href="fprob.f90">fprob.f90</a> Cumulative F distribution.
Requires <a href="bratio.f90">bratio.f90</a> for the incomplete
gamma function, and <a href="constant.f90">constant.f90</a>. N.B.
bratio.f90 contains code for a number of special functions
including the error function, the logarithm of the gamma function,
the logarithm of the beta function, and the digamma function.
bratio was translated from the NSWC library.</li>
<li><a href="dceigv.f90">dceigv.f90</a> Calculate the eigenvalues
and vectors of a general complex matrix. Another routine from the
NSWC library. Needs <a href="constant.f90">constant.f90</a>. Based
upon EISPACK routines. There is a test program: <a href=
"t_dceigv.f90">t_dceigv.f90</a></li>
<li><a href="locpt.f90">locpt.f90</a> Is a point inside a
polygon?</li>
<li><a href="qtcrt.f90">qtcrt.f90</a> Solve quadratic, cubic and
quartic equations. Includes a short driver program, and hence
includes the interfaces needed for your program. Adapted from the
NSWC library.</li>
<li><a href="toeplitz.f90">toeplitz.f90</a> Solution of Toeplitz
systems of linear equations.</li>
<li><a href="zeroin.f90">zeroin.f90</a> Finds a zero of a
user-supplied function in a specified range (a, b).</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="misc">Miscellaneous code</h2>

<ul>
<li><a href="qsort.f90">qsort.f90</a> A version of the quicksort
algorithm adapted from Walt Brainerd's code.</li>
<li><a href="cobyla.f90">cobyla.f90</a> Mike Powell's routine for
minimization of non-linear functions with smooth non-linear
constraints, using local linear approximations to the
constraints.</li>
<li><a href="tron.zip">tron.zip</a> Newton's method for large
bound-constrained optimization problems by Chih-Jen Lin &amp; Jorge
More', a MINPACK-2 project. Use PKUNZIP or WINZIP to unpack the
file.</li>
<li><a href="lm.zip">lm.zip</a> Levenberg-Marquardt algorithm for
non-linear least squares (unconstrained). This is a translation of
the MINPACK routines, LMDER &amp; LMDIF. Use LMDER for functions
which can be differentiated, and LMDIF when it is necessary to use
differences. The ZIPped file includes the MINPACK test programs,
and a simple example fitting a 4-parameter logistic.</li>
<li><a href="conmin.zip">conmin.zip</a> The classic CONMIN package
for constrained minimization updated to Fortran 90. Test examples
and the manual are included in the ZIP file. N.B. CONMIN is
included as just one of the algorithms in TOMS algorithm 734 which
can be downloaded from netlib (http://www.netlib.org).</li>
<li><a href="minim.f90">minim.f90</a> The Nelder-Mead simplex
algorithm for unconstrained minimization. It does NOT require or
use derivatives. N.B. This is NOT for linear programming! <a href=
"t_minim.f90">t_minim.f90</a> is a very simple test program for
minim.f90 which may help users. This is now ELF90-compatible.</li>
<li><a href="primefac.f90">primefac.f90</a> A program to find prime
factors.</li>
<li><a href="uobyqa.f90">uobyqa.f90</a> Mike Powell's package for
unconstrained minimization when derivatives are not available.
There is a test/driver program:<br />
<a href="t_uobyqa.f90">t_uobyqa.f90</a> and a file of results from
the test program:<br />
<a href="test.out">test.out</a> The documentation, which is in
gzipped postscript, can be downloaded from the <a href=
"http://plato.lasu.edu/topics/problems/nlounres.html">Optimization
Decision Tree</a>.</li>
<li><a href="tn.zip">tn.zip</a> Stephen Nash's truncated-Newton
code for the minimization of continuous functions. It can use
differences instead of derivatives, and bounds may be imposed on
the parameters.</li>
<li><a href="xdlegf.f90">xdlegf.f90</a> Legendre functions and
polynomials, from the CMLIB library.</li>
<li><a href="datesub.f90">datesub.f90</a> Some date manipulation
routines collected together by H.D. Knoble.</li>
<li><a href="global.f90">global.f90</a> At Arnold Neumaier's web
site, this is recommended as the most successful of the global
optimization packages. There is a sample program <a href=
"fit.f90">fit.f90</a> and the original documentation <a href=
"global.txt">global.txt</a> for the f77 version. I have included
<a href="testfunc.f90">testfunc.f90</a> which will eventually
contain all of Neumaier's 30 test functions. N.B. Users of local
optimization packages usually obtain satisfactory convergence after
10s or sometimes 100s of function evaluations. Global optimization
routines usually require many 1000s of function evaluations.</li>
<li><a href="tensolve.zip">tensolve.zip</a> A package for solving
sets of non-linear equations using Robert Schnabel's tensor method.
This is a translation of TOMS algorithm 768. The file was
compressed using PKZIP. It is now compatible with version 4.0 of
ELF90, but misbehaves on example 2.</li>
<li><a href="ks2.f90">ks2.f90</a> Calculates 1 and 2-tail
probabilities for the single-sample Kolmogorov-Smirnov statistic.
For 2-tail probabilities, it uses a combination of the first
algorithm from CACM 487, double the single-tail probability, and
the asymptotic distribution. See also TOMS algorithm 519.</li>
<li><a href="ncr.f90">ncr.f90</a> Calculates number of combinations
of r out of n.</li>
<li><a href="update.f90">update.f90</a> Three very short
subroutines to update the sample mean and sum of squares of
deviations about the mean (and hence update variances or std.
deviations), when one observation is added, dropped or replaced
with another. Designed for fast, repeated use with no checks.</li>
<li><a href="mvnpack.f90">mvnpack.f90</a> Alan Genz's package of 4
methods of evaluating multivariate normal integrals.</li>
<li><a href="bivnorm.f90">bivnorm.f90</a> A function for
calculating bivariate normal probabilities, extracted from Alan
Genz's package for multivariate normal integration.</li>
<li><a href="genz2d3d.f90">genz2d3d.f90</a> This is code for
bivariate and trivariate normal integrals which I discovered on
Alan Genz's web site. I have made it compatible with ELF90. It is
more recent (January 2001) than bivnorm above.</li>
<li><a href="dcuhre.f90">dcuhre.f90</a> Alan Genz's program for
general multivariate integration, not just of one function but
simultaneously for a vector of functions over the same multivariate
region. There is also a test program <a href=
"dtest1.f90">dtest1.f90</a> and a text file <a href=
"dcuhre.txt">dcuhre.txt</a>. which contains the results from the
test program (run in single precision) N.B. While the Fortran 77
version of this code is still at Alan Genz's web site, he is
referring users to the CUBPACK project at: <a href=
"http://www.cs.kuleuven.ac.be/~nines/research/CUBPACK">CUBPACK</a></li>
<li><a href="tfunc.f90">tfunc.f90</a> A module for calculating
bivariate normal probabilities using code by Baughman and
Patefield.</li>
<li><a href="t_bivnor.f90">t_bivnor.f90</a> Comparison of 3
functions for the bivariate normal - those of Donnelly (CACM 462),
Genz, and Baughman/Patefield.</li>
<li><a href="hash.f90">hash.f90</a> and <a href=
"hashord.f90">hashord.f90</a> Hashing routines by Richard Brent and
Donald Knuth, taken from Herman Noble's web site
(http://ftp.cac.psu.edu/pub/ger/fortran/).</li>
<li><a href="elsunc.f90">elsunc.f90</a> Per Lindstroem's package
for non-linear least squares with upper &amp; lower bounds on
parameter values. <a href="d_elsunc.f90">d_elsunc.f90</a>
demonstrates this package.</li>
<li><a href="solvopt.zip">solvopt.zip</a> The SolvOpt package
minimizes or maximizes nonlinear functions, which may be nonsmooth
and may have constraints, using the so-called method of exact
penalization. This is a zip file containing several driver
programs.</li>
<li><a href="ga.zip">ga.zip</a> A package for global minimization
using genetic algorithms. Please note the copyright conditions if
you want to use this for commercial purposes. This is a ZIP
file.</li>
<li><a href="pikaia.zip">pikaia.zip</a> Another genetic algorithm
for global optimization without derivatives. This one comes from
the High Altitude Observatory of NCAR. This is a ZIP file,
containing a number of interesting examples. There is an excellent
manual, but you will have to download it from <a href=
"http://www.hao.ucar.edu/public/research/si/pikaia/pikaia.html">their
web site</a>. N.B. The manual is 120 pages long, and in postscript.
Where does the name Pikaia come from? Pikaia gracilens is a
flattened worm-like beast about 5cm long which crawled in the mud
on the sea floor about 530 million years ago!</li>
<li><a href="cdfcor.zip">cdfcor.zip</a> A package for rational
(Pade) approximation in one and two dimensions. Includes a driver
for 9 test problems, input data and output. This is a ZIP
file.</li>
<li><a href="sym_band.f90">sym_band.f90</a> Find the
eigenvalues/vectors of a symmetric banded matrix stored in compact
form. Based upon EISPACK code.</li>
<li><a href="strassen.f90">strassen.f90</a> The Strassen fast
matrix multiply algorithm for large matrices. Code downloaded from
the comp.lang.fortran newsgroup.</li>
<li><a href="varpro.f90">varpro.f90</a> The VARPRO package for
separable nonlinear least squares is for fitting models of the
kind<br />
Y = a1.F1(x, b) + a2.F2(x, b) + ...<br />
in which the a's are linear parameters, the vector b is a vector of
nonlinear parameters, and the F's are nonlinear functions. An
important application is fitting sums of exponential decay terms. A
driver program <a href="twoexp.f90">twoexp.f90</a> is provided, as
well as the <a href="a.dat">data</a>.</li>
<li><a href="bvls.f90">bvls.f90</a> Fits a linear model using least
squares but with upper and lower bounds as constraints on each
regression coefficient.</li>
<li><a href="foldat73.f90">foldat73.f90</a> There is a compiler
which accepts Fortran code in fixed format extending beyond column
72, other than sequence numbers which occupy these columns in fixed
form. This simple program takes such code as input data and breaks
long lines after column 72 starting with a continuation character
in column 6.</li>
<li><a href="diehard.f90">DIEHARD</a> A version of George
Marsaglia's random number tests in standard Fortran. You will also
need the files <a href="tests.txt">tests.txt</a> and <a href=
"operm5d.ata">operm5d.ata</a>, and you will need to generate a
binary file containing just over 11 million random 32-bit integers
using the random number generator which you want to test. I have
provided a short note <a href="diehard.txt">diehard.txt</a> and an
example <a href="t_taus88.f90">t_taus88.f90</a> showing how to
generate the binary file using Pierre L'Ecuyer's TAUS88 random
number generator.</li>
<li><a href="sortchar.f90">sortchar.f90</a> Code for sorting
character strings. This was made available on the comp.lang.fortran
newsgroup. Author unknown.</li>
<li><a href="total_ls.f90">total_ls.f90</a> Van Huffel's Total
Least Squares. It can be used for least-squares regressions in
which there are errors in both the X and Y variables, but the user
must have first scaled the variables so that the errors in all
variables are all the same. Can be used for ODR (orthogonal
distance regression) after the same scaling, otherwise use ODRPACK
(a much larger package) from netlib, or Applied Statistics
algorithm AS 286. <a href="test_tls.f90">test_tls.f90</a> A test
program for total_ls requiring <a href=
"test_tls.dat">test_tls.dat</a>. <a href=
"ptls-doc.txt">ptls-doc.txt</a> is Van Huffel's doc-file.</li>
<li><a href="k_smooth.zip">k_smooth.zip</a> Eva Hermann's software
for kernel smoothing, both local (lokern) and global (glkern).</li>
<li><a href="ewma.f90">ewma.f90</a> Code for updating
exponentially-weighted moving averages, including updating a
residual sum of squares.</li>
<li><a href="adventur.zip">adventur.zip</a> This is a Fortran 90
version of the classic Adventure game.</li>
<li><a href="zhangjin.zip">zhangjin.zip</a> The source code from
`Computation of Special Functions' by Zhang &amp; Jin, published by
Wiley, 1996. As well as the `usual' functions such as gamma, error
function, Bessel and Airy functions, there are the confluent
hypergeometric, parabolic cylinder, Mathieu, spheroidal wave, and
various exponential integrals, etc.</li>
<li><a href="dli.f90">dli.f90</a> Code from the Slatec library for
the logarithmic integral, Li(x), and the exponential integrals,
Ei(x) and E1(x).</li>
<li><a href="dcosint.f90">dcosint.f90</a> &amp; <a href=
"dsinint.f90">dsinint.f90</a> are for evaluating the cosine, Ci(x),
and sine, Si(x), integrals respectively. They are translations of
Numerical Algorithm NA 12. There are corresponding test programs
<a href="dcitest.f90">dcitest.f90</a> &amp; <a href=
"dsitest.f90">dsitest.f90</a></li>
<li><a href="r_zeta.f90">r_zeta.f90</a> Riemann's zeta function for
real argument. Adapted from DRIZET in the MATHLIB library from
CERN.</li>
<li><a href="cincgam.f90">cincgam.f90</a> The incomplete gamma
function for complex arguments.</li>
<li><a href="assndx.f90">assndx.f90</a> The Munkres algorithm for
solution of the assignment problem. Adapted from a routine in the
MATHLIB library from CERN.</li>
<li><a href="easter.f90">easter.f90</a> When is Easter in year
XXXX?</li>
<li><a href="nnes.zip">nnes.zip</a> Code for the solution of
simultaneous non-linear equations using a variety of algorithms. No
documentation, but 3 example programs, one of which (MDR) contains
10 different problems. Warning: This code contains the statement
`Copyright R.S.Bain (1991)', but attempts to contact Rod Bain have
been unsuccesful. This too is a zipped file.</li>
<li><a href="lanczos.f90">lanczos.f90</a> A simple algorithm for
the logarithm of the gamma function.</li>
<li><a href="to_f90.f90">to_f90.f90</a> This program takes Fortran
77 code and converts it to make it look more like Fortran 90.</li>
<li><a href="kaiser.f90">kaiser.f90</a> A simple routine to
calculate the eigenvalues and eigenvectors of a symmetric positive
definite, e.g. a covariance matrix.</li>
<li><a href="singlton.f90">singlton.f90</a> The classic Singleton
multi-dimensional FFT algorithm for series whose length is not
necessarily a power of 2.</li>
<li><a href="fft_simple.f90">fft_simple.f90</a> A simple Fast
Fourier routine for the case in which the series length is a power
of 2.</li>
<li><a href="chirp.f90">chirp.f90</a> The Chirp-Z algorithm for the
FFT of a series of any length.</li>
<li><a href="fft235.f90">fft235.f90</a> Fast Fourier Transform for
the case in which the series length is a multiple of some or all of
the integers 2, 3 and 5 (e.g. length = 60 or 240).</li>
<li><a href="hartly2d.f90">hartly2d.f90</a> Hartley 2D Fast Fourier
Transform.</li>
<li id="pzeros"><a href="pzeros.f90">pzeros.f90</a> Solve polynomial equations using
Aberth's method. Translated from a Fortran 77 algorithm by Dario
Bini published in Numerical Algorithms, vol.13 (1996). A short test
program <a href="poly20.f90">poly20.f90</a> is also available.
Dario Bini has a package called MPSolve which does it in multiple
precision. It can be downloaded by ftp from:
http://fibonacci.dm.unipi.it/~bini/ric.html.</li>
<li><a href="envelope.f90">envelope.f90</a> A simple but efficient
routine for finding 2D convex hulls, i.e. in finding the minimum
polygon to enclose a set of points.</li>
<li><a href="median.f90">median.f90</a> Finds the median of a set
of numbers using a truncated quicksort algorithm.</li>
<li><a href="hermite.f90">hermite.f90</a> Hermite integration, that
is integration of f(x).p(x) from minus infinity to plus infinity,
where f(x) is the user's function and p(x) = exp(-x^2).</li>
<li><a href="hh.f90">hh.f90</a> Half-Hermite integration, that is
from zero to plus infinity. <a href="hh_test.f90">hh_test.f90</a>
is a test program which also serves as an illustration of how to
use hh. See below for a program to calculate in quadruple precision
the weights and abscissae.</li>
<li><a href="chi_sq.f90">chi_sq.f90</a> Chi-squared distribution
function. Requires as239.f90 and lanczos.f90.</li>
<li><a href="hyperg.f90">hyperg.f90</a> Calculate hypergeometric
probabilities.</li>
<li><a href="rhohat.f90">rhohat.f90</a> Maximum likelihood
estimation of the shape parameter of the gamma (Erlang)
distribution, including calculation of the derivatives of the
log-gamma function.</li>
<li><a href="fnprod.f90">fnprod.f90</a> Computes the distribution
function for the product of two correlated normal variates using
the algorithm of Meeker &amp; Escobar. Needs <a href=
"constant.f90">constant.f90</a> and <a href=
"qxgs.f90">qxgs.f90</a>.</li>
<li><a href="twodqd.f90">twodqd.f90</a> A translation of Kahaner
&amp; Rechard's 1984 program for bivariate integration over
triangular regions, including a test program.</li>
<li><a href="simann.f90">simann.f90</a> is a module and test
program for simulated annealing based upon the algorithm of
Corana.</li>
<li><a href="ives.f90">ives.f90</a> is a routine for generating all
combinations of n objects.</li>
<li><a href="mace.f90">mace.f90</a> is an F90 version of Jerry
Friedman's program to estimate multiple optimal transformations for
regression and correlation by alternating conditional expectation
estimates.</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="nas">10-byte REAL code for NAS FortranPlus<br /></h2>

<p>This exploits the 10-byte REAL data type which is supported by
this compiler. At the moment, it only contains a special version of
my quadruple precision package which gives about 38 decimal digit
representation of quadruple precision numbers. N.B. It is extremely
unlikely that this will give correct answers with any other
compiler (e.g. Salford) which supports 10-byte REALs.</p>
<ul>
<li><a href="quad_nas.f90">quad_nas.f90</a> Module for quadruple
precision arithmetic using operator overloading.</li>
<li>There is a short test program <a href=
"t_quad_nas.f90">t_quad_nas.f90</a>, for testing the basic
arithmetic operations (+-*/), and other test programs <a href=
"t_cubert_nas.f90">t_cubert_nas.f90</a>, <a href=
"t_cst_nas.f90">t_cst_nas.f90</a>, <a href=
"t_logexp_nas.f90">t_logexp_nas.f90</a> and <a href=
"t_arc_nas.f90">t_arc_nas.f90</a>,for testing logs, exponential and
trigonometric functions.</li>
<li><a href="qcomplex_nas.f90">qcomplex_nas.f90</a> Module for
complex arithmetic in quadruple precision.</li>
<li><a href="q_cpoly_nas.f90">q_cpoly_nas.f90</a> The classic
Jenkins/Traub algorithm for finding the zeroes of a polynomial
equation with complex coefficients. Originally published as CACM
algorithm 419.</li>
<li><a href="q_rpoly_nas.f90">q_rpoly_nas.f90</a> The classic
Jenkins/Traub algorithm for finding the zeroes of a polynomial
equation with real coefficients. Originally published as CACM
algorithm 493.</li>
<li><a href="hilbert_nas.f90">hilbert_nas.f90</a> Simple program to
invert a Hilbert matrix.</li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="f">Code for Imagine1's F compiler</h2>


<h3>Quadruple Precision Code</h3>

<ul>
<li><a href="quad.f">quad.f</a> The main module for quadruple
precision.<br />
N.B. This version includes functions for complex arithmetic. I have
only tested it with the Windows version of F. I am told that it
also works with Linux on PCs. On machines which do not use the
Intel (or similar) CPU with an 80-bit FPU, try deleting that `11'
from the expression for the real (DP), parameter :: const<br />
The IEEE double precision format has a 53-bit mantissa, compared
with 64 bits for the Intel FPU, hence that 11. Problems with other
computers are most likely to occur with the exponential and trig.
functions, so make sure that you test these.</li>
<li><a href="t_quad.f">t_quad.f</a> A simple test program. Various
test quantities, e.g. (a^2 - b^2) = (a-b)*(a+b) are calculated in
two different ways and the results compared. All of the differences
should be of the order of 10^(-30) or zero.</li>
<li><a href="t_logexp.f">t_logexp.f</a> and <a href=
"t_cst.f">t_cst.f</a> Simple tests of the logarithmic and
trigonometric functions.</li>
<li><a href="q_erf.f">q_erf.f</a> The error function and its
complement. The file includes a test program which differences the
calculated values and compares it with the derivative.</li>
<li><a href="q_lngam.f">q_lngam.f</a> The log-gamma function,
including a test program.</li>
<li><a href="q_pzeros.f">q_pzeros.f</a> A module for calculating
the zeroes of polynomials. There is also a demo program <a href=
"q_poly20.f">q_poly20.f</a>.</li>
</ul>

<h3>Other code for F</h3>

<ul>
<li><a href="krout.f">krout.f</a> A module for solving linear
equations and inverting matrices.</li>
<li><a href="lsq.f">lsq.f</a> A module for multiple linear
regression using least squares, based upon Applied Statistics
algorithm AS 274. There is a <a href="demo.f">demo program</a>
which requires a <a href="fuelcons.dat">data set</a></li>
</ul>
<p class="back"><a href="#top">Back to top</a></p>
<hr />

<h2 id="lsq">Some linear least-squares examples and tests</h2>

<ul>
<li><a href="fit_poly.f90">fit_poly.f90</a> Fit a polynomial to a
set of (x,y) data.</li>
<li><a href="quadsurf.f90">quadsurf.f90</a> Fit a quadratic surface
to a set of (x,y,z) data, i.e. fit:<br />
Z = b0 + b10.X + b01.Y + b20.X^2 + b11.X.Y + b02.Y^2<br />
There is a module <a href="ridge.f90">ridge.f90</a> for ridge
regression / regularization. It uses the output from the module lsq
to form the singular value decomposition (SVD) and offers a choice
of 4 different methods of regularization, or the user can input
their own vector to add to the diagonal of the X'X-matrix.</li>
<li><a href="wtd_quin.f90">wtd_quin.f90</a> This is a program to
fit a quintic polynomial with exponential weighting of past values.
It was developed for someone who had reason to believe that his
process was well approximated locally by a quintic, but wanted to
give progressively less weight to old observations. The slope and
2nd derivative (acceleration) of the smoothing polynomial are
output after each new case is read. This is suitable for real time
applications. It demonstrates the use of the least-squares
package's updating algorithm.</li>
<li><a href="spline5.f90">spline5.f90</a> This program fits quintic
splines with user-chosen but evenly-spaced knots. The slope and 2nd
derivative (acceleration) of the smoothing polynomial are output,
but only after all of the data have been read. The smoothed fit and
derivatives at any point are based upon the data from both before
and after the point.</li>
</ul>

<p class="back"><a href="#top">Back to top</a></p>

<hr />

<h2 id="links">Some other useful web sites:</h2>

<p>Try the <a href="http://www.fortran.com/fortran">Fortran
Market</a> for general information on Fortran compilers, tutorials,
books and access to some sources of Fortran code, Gary Scott's
<a href="http://www.fortranlib.com/">Fortran Library</a> web
site.<br />
The Fortran90 FAQ (frequently asked questions) can be obtained
from: <a href="http://www.ifremer.fr/ditigo/molagnon/fortran90/engfaq.html">F90FAQ</a>.<br />

For an extensive set of routines for sorting and ranking real
numbers see <a href="http://www.fortran-2000.com/">OrderPack</a>.<br />
<a href="http://www.nag.co.uk/nagware/Examples.asp">NAG F90
Software Repository</a> is a source of useful Fortran 90
code.<br />
The ACM collection of <a href="http://www.netlib.org/toms/index.html">TOMS algorithms</a> is a
source of refereed code, mainly in Fortran, for a wide range of
numerical calculations.<br />
A collection of functions and subroutines covering a wide area of
mathematical<br />
John Monahan's site contains the software from his book `Numerical
Methods of Statistics'. It covers a very similar are to this web
site, and is at: <a href="http://www4.stat.ncsu.edu/~monahan/aug00/toc.htm">Monahan's web
site</a>. operations can be found at <a href="http://perso.wanadoo.fr/jean-pierre.moreau/fortran.html">Jean-Pierre Moreau's web site</a>.<br />
For a guide to available mathematical software, refer to <a href=
"http://gams.nist.gov/">GAMS</a>, and for the numerical analysis
FAQ <a href="http://www.mathcom.com/corpdir/techinfo.mdir/scifaq/">numafaq</a>.<br />

If you are interested in object-oriented programming in Fortran,
you should see <a href="http://www.cs.rpi.edu/~szymansk/oof90.html">oof90.html</a>.<br />
For statistical software in a variety of languages try <a href="http://lib.stat.cmu.edu/">statlib</a>. For distribution functions,
random number generation and other statistical programs, try
<a href="http://odin.mdacc.tmc.edu/pub/source">cdflib/ranlib</a>.<br />
For optimization, particularly constrained optimization, see
<a href="http://plato.la.asu.edu/guide.html">the Optimization
Decision Tree</a>, or Arnold Neumaier's <a href="http://www.mat.univie.ac.at/~neum/glopt.html">Global
Optimization</a> web site. The latter also contains many general
links to mathematical and statistical software.<br />
For multivariate normal integrals, and for multiple integration in
general, look at <a href="http://www.math.wsu.edu/math/faculty/genz/homepage">Alan
Genz's</a> home page.<br />
Michel Olagnon's ORDERPACK is for sorting and ranking. It can be
found at: <a href="http://www.fortran-2000.com/">ORDERPACK</a>.<br />
Australian Fortran users will find the web page of <a href=
"http://www.labyrinth.net.au/~ctrans">Computer Transition
Systems</a> useful. (This company distributes Lahey, Salford,
Edinburgh Portable Compilers, Digital Visual Fortran and other
compilers in Australia.)<br />
To download Lahey's cheap Fortran 90 compiler click on <a href=
"http://www.lahey.com/">ELF90</a>.</p>
<p>
There is an interpreter for a subset of Fortran 90 available from:
<a href="http://www.HicEst.com/">Georg Petrich's interpreter</a>. I
have not tried it myself, so comments would be welcome. It can be
downloaded freely, but I understand it is a shareware
product.<br />
For a wide range of code for the FFT, in several computer
languages, see: <a href="http://www.fftw.org/links.html">The FFT
Home Page</a>. and: <a href="http://www.jjj.de/fft/fftpage.html">Another FFT Home Page</a>.</p>
<p><b>email:</b> <a href="mailto:amiller@bigpond.net.au">amiller@bigpond.net.au</a></p>

<p class="back"><a href="#top">Back to top</a></p>

<hr />

<p class="center">Updated 4 February 2004</p>

</body>
</html>
