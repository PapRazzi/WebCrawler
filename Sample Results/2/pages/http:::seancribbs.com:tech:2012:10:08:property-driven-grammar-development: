<!DOCTYPE html>
<html lang='en-US' xml:lang='en-US' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>Property-Driven Grammar Development -
    sean cribbs :: digital renaissance man</title>
    <link href='/stylesheets/baseline.css' rel='stylesheet' type='text/css' />
    <link href='/stylesheets/layout.css' rel='stylesheet' type='text/css' />
    <link href='/stylesheets/code.css' rel='stylesheet' type='text/css' />
    
  </head>
  <body>
    <div id='header'>
      <h1>Sean<span>Cribbs</span></h1>
      <h2>Digital Renaissance Man</h2>
    </div>
    <ul id="navigation">
<li><a href="/">home</a></li> 
<li><a href="/portfolio/">portfolio</a></li> 
<li><a href="/about/">about</a></li> 
<li><a href="/contact/">contact</a></li> 
</ul>

    <div id='content'>
      <div id='sidebar'>
        
        <h1>Tech Archives</h1>
<div class="left-box">
<ul>
  
  <li><a href="/tech/2012/10/">October 2012</a></li>
  
  <li><a href="/tech/2012/02/">February 2012</a></li>
  
  <li><a href="/tech/2012/01/">January 2012</a></li>
  
  <li><a href="/tech/2011/11/">November 2011</a></li>
  
  <li><a href="/tech/2011/07/">July 2011</a></li>
  
  <li><a href="/tech/2011/03/">March 2011</a></li>
  
  <li><a href="/tech/2011/01/">January 2011</a></li>
  
  <li><a href="/tech/2010/09/">September 2010</a></li>
  
  <li><a href="/tech/2010/04/">April 2010</a></li>
  
  <li><a href="/tech/2010/02/">February 2010</a></li>
  
  <li><a href="/tech/2010/01/">January 2010</a></li>
  
  <li><a href="/tech/2009/12/">December 2009</a></li>
  
  <li><a href="/tech/2009/11/">November 2009</a></li>
  
  <li><a href="/tech/2009/09/">September 2009</a></li>
  
  <li><a href="/tech/2009/08/">August 2009</a></li>
  
  <li><a href="/tech/2009/07/">July 2009</a></li>
  
  <li><a href="/tech/2009/06/">June 2009</a></li>
  
  <li><a href="/tech/2009/05/">May 2009</a></li>
  
  <li><a href="/tech/2009/03/">March 2009</a></li>
  
  <li><a href="/tech/2009/02/">February 2009</a></li>
  
  <li><a href="/tech/2009/01/">January 2009</a></li>
  
  <li><a href="/tech/2008/09/">September 2008</a></li>
  
  <li><a href="/tech/2008/07/">July 2008</a></li>
  
  <li><a href="/tech/2008/05/">May 2008</a></li>
  
  <li><a href="/tech/2008/04/">April 2008</a></li>
  
  <li><a href="/tech/2008/02/">February 2008</a></li>
  
  <li><a href="/tech/2007/12/">December 2007</a></li>
  
  <li><a href="/tech/2007/11/">November 2007</a></li>
  
  <li><a href="/tech/2007/10/">October 2007</a></li>
  
  <li><a href="/tech/2007/09/">September 2007</a></li>
  
  <li><a href="/tech/2007/08/">August 2007</a></li>
  
  <li><a href="/tech/2007/07/">July 2007</a></li>
  
  <li><a href="/tech/2007/06/">June 2007</a></li>
  
  <li><a href="/tech/2007/05/">May 2007</a></li>
  
  <li><a href="/tech/2007/04/">April 2007</a></li>
  
  <li><a href="/tech/2007/03/">March 2007</a></li>
  
  <li><a href="/tech/2007/02/">February 2007</a></li>
  
  <li><a href="/tech/2007/01/">January 2007</a></li>
  
  <li><a href="/tech/2006/12/">December 2006</a></li>
  
  <li><a href="/tech/2006/11/">November 2006</a></li>
  
  <li><a href="/tech/2006/10/">October 2006</a></li>
  
  <li><a href="/tech/2006/09/">September 2006</a></li>
  
  <li><a href="/tech/2006/08/">August 2006</a></li>
  
</ul>
</div>

        
      </div>
      <div id='main'>
        
<h2>Property-Driven Grammar Development</h2>

<p>Back when I first learned about parsing expression grammars (PEGs), I was impressed by the test-driven grammar development demo that the author of Treetop had created. TDD, BDD, and friends are a given in the Ruby community, but are not as popular in the Erlang world. On the other hand, QuickCheck is the most powerful tool for testing Erlang, given that it can generate random test cases and quickly reduce found errors to the minimal failing case (the most important part!).</p>

<p>A few weeks ago Rich Hickey released an informal specification <code>edn</code>, a subset of Clojure syntax for expressing data, and the on-the-wire format for Datomic. Since I have a <a href='https://github.com/seancribbs/neotoma'>PEG/Packrat tool</a> and QuickCheck, it seemed like a perfect weekend project to attempt property-driven development on. (With minimal modification, one could use PropEr or Triq to do this, too.) I&#8217;m not going to go into detail about how to use QuickCheck, but I&#8217;ll try to cover the relevant bits as I go.</p>

<p>Now, the interesting part about testing a parser with QuickCheck is that you have to do the work twice! That is, you must define a generator for a subset of the language at the same time that you develop the rule that parses it; the challenge will be avoiding the &#8220;ugly mirror&#8221; problem. With some more formal methods than I take here, one might be able to use the grammar as both generator and parser, an exercise I leave to you, kind reader.</p>

<p>Usually I try to attack developing a grammar by selecting the simplest construct &#8211; usually a terminal deep in the syntax tree &#8211; and implementing that, then build up the language as I go with more terminals and simple non-terminals until I reach the top level. Since the simplest and most prolific terminal in <code>edn</code> is whitespace, we&#8217;ll start there. In my first pass at this, I started by writing my properties in the grammar file, but that quickly became unmanageable, so my examples below will keep them separate. Whitespace in <code>edn</code> is defined as any tab character, carriage return, linefeed, horizontal space, or comma, so let&#8217;s create a QuickCheck generator for that.</p>
<pre>
<code class='erlang'>%% edn_eqc.erl
-module(edn_eqc).
-ifdef(EQC).
-compile([export_all]).
-include_lib("eqc/include/eqc.hrl").

gen_ws() -> oneof([9, 10, 11, 12, 13, 32, $,]).

-endif.
</code>
</pre>
<p>I use the <code>oneof</code> generator because each of the whitespace types is independent and none are preferred over another, meaning that they don&#8217;t need to shrink to a specific value. Since we need binaries and not just bytes as parser input, and all streams in <code>edn</code> are UTF-8 encoded, let&#8217;s modify the generator a little bit and add a convenience macro for converting to UTF-8.</p>
<pre>
<code class='erlang'>%% [snip]
-define(to_utf8(X), unicode:characters_to_binary(lists:flatten(X), utf8, utf8)).

gen_ws() ->
    ?LET(X,
         list(oneof([9, 10, 11, 12, 13, 32, $,])),
         ?to_utf8(X)).
</code>
</pre>
<p>The <code>?LET</code> macro allows you to wrap a non-abstract operation around a generator so that you can modify the concrete value after it is generated, while still returning a generator that QuickCheck can understand. Now we can sample that generator and see if it makes sense. (Note that I&#8217;ve skipped over some setup stuff you&#8217;ll need to do with rebar to make it a proper app. I put <code>edn_eqc.erl</code> in <code>test/</code>.)</p>

<pre><code>$ rebar get-deps compile eunit compile_only=true
$ erl -pa .eunit
 
1&gt; eqc_gen:sample(edn_eqc:gen_ws()).
&lt;&lt;&quot;\t \n&quot;&gt;&gt;
&lt;&lt;&gt;&gt;
&lt;&lt;&quot;\f &quot;&gt;&gt;
&lt;&lt;&gt;&gt;
&lt;&lt;&quot;\f\r,\f,&quot;&gt;&gt;
&lt;&lt;&gt;&gt;
&lt;&lt;&quot; \v\r\n&quot;&gt;&gt;
&lt;&lt;&quot;,\f\n&quot;&gt;&gt;
&lt;&lt;&quot;\n, \n\v\n&quot;&gt;&gt;
&lt;&lt;&gt;&gt;
&lt;&lt;&gt;&gt;
ok</code></pre>

<p>Great, now we should define what the property of parsing whitespace should be, namely, that it is ignored. However, given that <code>edn</code> can be used to stream data, and has a native list type, returning an empty list when the stream has only whitespace would not make sense. Returning a tagged <code>error</code> tuple, which is Erlang&#8217;s convention, would also be presumptious, given that <code>edn</code> has a tuple type. Therefore, I&#8217;m going to choose to return a sentinel value of <code>&#39;$space&#39;</code> for now, and I&#8217;ll later insert a throw at the top level so we can detect empty streams. Luckily, it will be simple to change this later.</p>
<pre>
<code class='erlang'>%% Must be after the EQC include, since it will try to define similar
%% macros.
-include_lib("eunit/include/eunit.hrl"). 

%% [snip]

prop_whitespace() ->
    ?FORALL(Spaces, gen_ws(),
           '$space' == edn:parse(Spaces)).
</code>
</pre>
<p>Now let&#8217;s run it!</p>

<pre><code>$ rebar qc
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled test/edn_eqc.erl
prop_whitespace: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
Failed! Reason: 
{&#39;EXIT&#39;,{undef,[{edn,parse,[&lt;&lt;&gt;&gt;],[]},
                {edn_eqc,&#39;-prop_whitespace/0-fun-0-&#39;,1,
                         [{file,&quot;test/edn_eqc.erl&quot;},{line,16}]},
                {eqc,&#39;-f777_0/2-fun-4-&#39;,3,[]},
                {eqc_gen,&#39;-f321_0/2-fun-0-&#39;,5,[]},
                {eqc_gen,f186_0,2,[]},
                {eqc_gen,&#39;-f321_0/2-fun-0-&#39;,5,[]},
                {eqc_gen,f186_0,2,[]},
                {eqc_gen,gen,3,[]}]}}
After 1 tests.
&lt;&lt;&gt;&gt;
ERROR: One or more QC properties didn&#39;t hold true:
[prop_whitespace]</code></pre>

<p>Woops, we got <code>undef</code> because we didn&#8217;t define our grammar module yet! Let&#8217;s open up <code>edn.peg</code> and add the grammar rule.</p>
<pre>
<code class='erlang'>whitespace &lt;- [,\s\v\f\r\n\t]+ `'$space'`;
</code>
</pre>
<p>Briefly, we&#8217;ve defined the <code>whitespace</code> non-terminal as parsing from one-or-more characters in the class of visible whitespaces plus the comma character, and returning the Erlang atom <code>&#39;$space&#39;</code>. Now let&#8217;s compile the grammar and try it again.</p>

<pre><code>$ rebar compile qc skip_deps=true
==&gt; edn (compile)
Compiled src/edn.peg
src/edn.erl:109: Warning: function p_all/4 is unused
Compiled src/edn.erl
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
src/edn.erl:109: Warning: function p_all/4 is unused
Compiled src/edn.erl
Compiled test/edn_eqc.erl
prop_whitespace: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
Failed! After 1 tests.
&lt;&lt;&gt;&gt;
ERROR: One or more QC properties didn&#39;t hold true:
[prop_whitespace]
ERROR: qc failed while processing /Users/sean/Development/edn: rebar_abort</code></pre>

<p>Hmm, an empty content is a valid input, but shouldn&#8217;t be recognized as a space. Let&#8217;s make that generator predicated as non-empty on the property.</p>
<pre>
<code class='erlang'>%% QuickCheck property for whitespace
prop_whitespace() ->
    ?FORALL(Spaces, non_empty(gen_ws()),
           '$space' == edn:parse(Spaces)).
</code>
</pre>
<pre><code>$ rebar compile qc skip_deps=true
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
src/edn.erl:109: Warning: function p_all/4 is unused
Compiled src/edn.erl
Compiled test/edn_eqc.erl
prop_whitespace: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests</code></pre>

<p>Alright, we can parse whitespace! <em>*facepalm*</em> Let&#8217;s quickly add a few more simple language constructs, namely <code>nil</code> and booleans so we can see how to start building up the structure around these terminals. Again we start with the generators:</p>
<pre>
<code class='erlang'>gen_nil() -> &lt;&lt;"nil">>.

gen_bool() -> oneof([&lt;&lt;"true">>, &lt;&lt;"false">>]).
</code>
</pre>
<p>Native Erlang values generate themselves in QuickCheck, so simply returning the <code>&lt;&lt;&quot;nil&quot;&gt;&gt;</code> value means that that will always be generated from the <code>gen_nil()</code> function. We can sample those generators again if we like, but they will be unsurprising. Instead, let&#8217;s define a property for <code>nil</code>:</p>
<pre>
<code class='erlang'>prop_nil() ->
    ?FORALL(Nil, ws_wrap(gen_nil()),
            nil == edn:parse(Nil)).
</code>
</pre>
<p>Notice I haven&#8217;t defined that <code>ws_wrap</code> function yet. Remember that our goal here was to treat whitespace simply as a separator, so the property we want to define is that a real terminal surrounded by whitespace parses into that terminal. Let&#8217;s teach QuickCheck how to wrap things in whitespace by making another generator, using our handy <code>?LET</code> macro again:</p>
<pre>
<code class='erlang'>%% Wrap another generator in whitespace
ws_wrap(Gen) ->
    ?LET({LWS, V, TWS}, 
         {gen_ws(), Gen, gen_ws()},
         ?to_utf8([LWS, V, TWS])).
</code>
</pre>
<p>Thanks to <code>?LET</code>, <code>ws_wrap</code> defines a generator that will create some amount of leading whitespace (maybe none), evaluate the passed generator, and then some trailing whitespace (maybe none) and flatten it into a UTF-8 binary. Perfect, check that property!</p>

<pre><code>$ rebar qc skip_deps=true
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled test/edn_eqc.erl
prop_nil: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
Failed! After 1 tests.
&lt;&lt;&quot;nil&quot;&gt;&gt;
prop_whitespace: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
ERROR: One or more QC properties didn&#39;t hold true:
[prop_nil]
ERROR: qc failed while processing /Users/sean/Development/edn: rebar_abort</code></pre>

<p>We&#8217;ve got a failing property again, and look how it shrunk! It&#8217;s easy to see what broke, namely that, <em>DUH</em>, we didn&#8217;t define how to parse nil. That&#8217;s easy to fix:</p>
<pre>
<code class='erlang'>nil &lt;- "nil" `nil`;
whitespace &lt;- [,\s\v\f\r\n\t]+ `'$space'`;
</code>
</pre>
<p>Now, I could run the property again, but I&#8217;ll save you the pain; simply adding that rule isn&#8217;t going to cut it because nil must be surroundable by whitespace. Also, <code>neotoma</code> won&#8217;t compile that grammar because it contains nonterminals that are not referred anywhere else &#8211; its convention is that the first rule is the entry point to the grammar. Let&#8217;s add some rules that allow us to describe the syntactic form of whitespace, and the semantic behavior of empty streams at the same time.</p>
<pre>
<code class='erlang'>edn &lt;- whitespace? (term:term whitespace?)* `
case Node of
  %% Nothing but whitespace
  [ _, []] -&gt;
        throw({edn,empty});
  %% Just one datum
  [ _, [[{term,Term}, _]]] -&gt;
       Term;
  %% Lots of terms
  [ _, Terms ] -&gt;
        [ T || [{term, T}, _WS] &lt;- Terms ]
end
`;
 
term &lt;- nil ~;
nil &lt;- "nil" `nil`;
whitespace &lt;- [,\s\v\f\r\n\t]+ `'$space'`;
</code>
</pre>
<p>This is the first time we&#8217;ve seen significant code in the grammar, so I&#8217;ll try to describe what&#8217;s going on. In <code>neotoma</code> grammars, you can include inline code between backticks or comment-braces (<code>%{</code>, <code>%}</code>) that will be run when a rule is successfully parsed. Within that code block, the variable <code>Node</code> is sequence of terms that was parsed, so you can manipulate that to build the data structures you want to result from the parse. In the previous two rules, we&#8217;ve been ignoring the parse result and simply returning static values. In our new <code>term</code> rule, we are using the special-form of <code>~</code> to skip doing any transformation, which is the equivalent of writing <code>%{ Node %}</code>, but much less noisy.</p>

<p>Now let&#8217;s focus our attention on the top-level rule, <code>edn</code>, which encapsulates our whitespace and stream behavior. It says that leading whitespace is optional, followed by zero-or-more terms separated by whitespace. We tag the terms as they are parsed so they are easier to pattern-match on and extract. Now in the code block, we can do something with parse. If the parenthesized portion parses zero times, the result will be an empty list, so we handle that case by throwing a special term like I mentioned above. In the case of parsing only a single term, we want to return <strong>only</strong> that term, and it not wrapped in a list, so we special-case that parse as well. Finally, if there is a stream of terms, for now we will just extract them and return them in a list.</p>

<p>Let&#8217;s recompile the grammar and try our properties again.</p>

<pre><code>$ rebar compile qc skip_deps=true
==&gt; edn (compile)
Compiled src/edn.peg
Compiled src/edn.erl
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled src/edn.erl
prop_nil: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_whitespace: Failed! Reason: 
{&#39;EXIT&#39;,{{case_clause,{edn,empty}},
         [{eqc,&#39;-f777_0/2-fun-4-&#39;,3,[]},
          {eqc_gen,&#39;-f321_0/2-fun-0-&#39;,5,[]},
          {eqc_gen,f186_0,2,[]},
          {eqc_gen,&#39;-f321_0/2-fun-0-&#39;,5,[]},
          {eqc_gen,f186_0,2,[]},
          {eqc_gen,gen,3,[]},
          {eqc,&#39;-f758_0/1-fun-2-&#39;,3,[]},
          {eqc_gen,&#39;-f321_0/2-fun-1-&#39;,4,[]}]}}
After 1 tests.
ERROR: One or more QC properties didn&#39;t hold true:
[prop_whitespace]
ERROR: qc failed while processing /Users/sean/Development/edn: rebar_abort</code></pre>

<p>Woops, we broke the whitespace property because we didn&#8217;t expect the throw! (One might call this letting your code get ahead of your tests.) Let&#8217;s change that to use an assertion provided by <code>eunit</code>.</p>
<pre>
<code class='erlang'>%% You must put this AFTER the EQC header file.
-include_lib("eunit/include/eunit.hrl").

%% [snip]

prop_whitespace() ->
    ?FORALL(Spaces, gen_ws(),
            ok == ?assertThrow({edn, empty}, edn:parse(Spaces))).
</code>
</pre>
<p>Run that one more time.</p>

<pre><code>$ rebar qc skip_deps=true
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled test/edn_eqc.erl
prop_nil: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_whitespace: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests</code></pre>

<p>Cool, now we can integrate that boolean generator and write a property for it.</p>
<pre>
<code class='erlang'>prop_bool() ->
    ?FORALL(Boolean, ws_wrap(gen_bool()),
            lists:member(edn:parse(Boolean), [true, false])).
</code>
</pre>
<p>I think you get the drill now, let&#8217;s assume you ran that, you would get the <code>{edn, empty}</code> thrown because it will stop parsing at the first valid tree before an unknown character. Let&#8217;s add the rule to the grammar:</p>
<pre>
<code class='erlang'>edn &lt;- whitespace? (term:term whitespace?)* `
case Node of
  %% Nothing but whitespace
  [ _, []] ->
        throw({edn,empty});
  %% Just one datum
  [ _, [[{term,Term}, _]]] ->
       Term;
  %% Lots of terms
  [ _, Terms ] ->
        [ T || [{term, T}, _WS] &lt;- Terms ]
end
`;

term &lt;- boolean / nil ~;
boolean &lt;- "true" / "false" `binary_to_existing_atom(Node, utf8)`;
nil &lt;- "nil" `nil`;
whitespace &lt;- [,\s\v\f\r\n\t]+ `'$space'`;
</code>
</pre>
<p>On the <code>term</code> rule, we just added <code>boolean</code> to one of the possible terms, using ordered choice, and use the <code>binary_to_existing_atom/2</code> BIF in the <code>boolean</code> rule to create the proper Erlang term. One last time, let&#8217;s compile the grammar and run the properties:</p>

<pre><code>$ rebar compile qc skip_deps=true
==&gt; edn (compile)
Compiled src/edn.peg
Compiled src/edn.erl
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled src/edn.erl
prop_nil: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,10,11},{11,19,8}}
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_whitespace: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_bool: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests</code></pre>

<h2 id='puzzler'>Puzzler</h2>

<p>So far I&#8217;ve lead you through it by hand, including most of the missteps along the way. I&#8217;ve gone way past this point in the <a href='https://github.com/seancribbs/edn-erlang'>actual project</a>, including doing more complicated-to-parse types like numbers. Given the grammar and properties in the project on Github, can you figure out why <code>prop_symbol()</code> fails? The answer is subtle.</p>

<pre><code>$ rebar qc skip_deps=true
==&gt; edn (qc)
NOTICE: Using experimental &#39;qc&#39; command
Compiled test/edn_eqc.erl
Compiled src/edn.erl
prop_whitespace: Starting Quviq QuickCheck version 1.25.1
   (compiled at {{2011,10,1},{13,42,22}})
Licence for Basho reserved until {{2012,9,30},{14,35,1}}
....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_bool: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_nil: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_unescape: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_string: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_symbol: ............................................................................................................................................................................................................................................................................Failed! After 269 tests.
&lt;&lt;&quot;\v\v\n\r  ,, ,\r\t-3fAloF0oZXp8 ,&quot;&gt;&gt;
Shrinking...(3 times)
&lt;&lt;&quot;-3&quot;&gt;&gt;
prop_character: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_integer: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
prop_float: ....................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................
OK, passed 500 tests
ERROR: One or more QC properties didn&#39;t hold true:
[prop_symbol]
ERROR: qc failed while processing /Users/sean/Development/edn:
rebar_abort</code></pre>
<script type="text/javascript">var
  disqus_url="http://seancribbs.com/tech/2012/10/08/property-driven-grammar-development/";</script><div id="disqus_thread"></div><script type="text/javascript"
  src="http://disqus.com/forums/seancribbs/embed.js"></script><noscript><a href="http://seancribbs.disqus.com/?url=http://seancribbs.com/tech/2012/10/08/property-driven-grammar-development/">View
  the discussion thread.</a></noscript><a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>


      </div>
    </div>
    <div id='footer'>
      &copy; 2006-present Sean Cribbs &mdash; Powered by
      <a href='http://nanoc.stoneship.org'>nanoc3</a> &amp;
      <a href='http://pages.github.com'>github:pages</a>
      &mdash; Some icons by <a href="http://www.famfamfam.com/lab/icons/silk/">FamFamFam</a>
    </div>
    <script src="/javascripts/code_highlighter.js" type="text/javascript"></script>
    <script src="/javascripts/ruby.js" type="text/javascript"></script>
    <script src="/javascripts/erlang.js" type="text/javascript"></script>
    <script src="/javascripts/radius.js" type="text/javascript"></script>
    <script src="/javascripts/css.js" type="text/javascript"></script>
    <script src="/javascripts/haml.js" type="text/javascript"></script>
    <script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4413101-1");
pageTracker._initData();
pageTracker._trackPageview();
</script>
    <script type="text/javascript">
//<![CDATA[
(function() {
		var links = document.getElementsByTagName('a');
		var query = '?';
		for(var i = 0; i < links.length; i++) {
			if(links[i].href.indexOf('#disqus_thread') >= 0) {
				query += 'url' + i + '=' + encodeURIComponent(links[i].href) + '&';
			}
		}
		document.write('<script charset="utf-8" type="text/javascript" src="http://disqus.com/forums/seancribbs/get_num_replies.js' + query + '"></' + 'script>');
	})();
//]]>
</script>

  </body>
</html>
